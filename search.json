[{"title":"Git知识总结","url":"/2021/07/16/Git知识总结/","content":"\n## 1.简介\n\n### 1.1git 定义\n\n​ git 是一个免费的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事物。\n\n不管是软件开发还是什么行业，代码、文档都不是一次性写完的，都需要有无数次的修改，无数个版本迭代，而 Git 是一个很好的版本管理工具。这次写的不满意，可以直接回滚到自己想要的版本。\n\n​ Git 的作者是 Linus ，没错，就是写了 Linux 系统的那个大佬 Linus，是他花了两周的时间用 C 写了这款分布式版本控制系统，狠人就是狠人啊,现在基本上就是最大的分布式版本管理系统了。\n\n### 1.2Github 和码云\n\n​ Github 是一个是一个用 git 做版本控制的项目托管平台，同样的中国还有码云。两者都是使用 git 做版本控制的项目托管平台，说白了，就是一个代码仓库。\n\n​ Github 与 码云其实在功能使用上并没有什么大的区别，比较显著的区别， Github 是全球最大的代码托管仓库，资源丰富，一句话说就是只有你想不到，没有他做不到的。代码资源十分丰富，但是有些不可名状的原因，导致了其网速有点那啥，但是还是可以用的。码云相对来说资源并没有那么丰富，但是好在其是国内的代码仓库，速度相对来说稍微好一些。\n\n​ 还有就是都提供了免费的静态网页功能，可以通过其规定特定的特殊，域名访问网站。还有应该是近来出现不久的免费的功能，免费的私有仓库，之前在 Github 上，要建私有仓库是需要花钱的。\n\n​ 有一个挺不错的方法就是拿 Github 当作自己的网盘，平时来存储一些文件什么的还是挺不错的，当然了，还是有限制的，单个文件不能超过 100M ，然后每个项目不能超过 1G。其实一般来说足够了，毕竟是免费的。\n\n​ **简单来说， Git 是一种方法。而 GitHub 只是使用这种方法的一个代码仓库。方法只有一个，而采用这种方法的却又很多个，类似 Github 和码云的还有 Gitlab 等。**\n\n## 2.Git 和 Svn 区别\n\n### 2.1Svn\n\n​ SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。\n\n​ 集中式版本控制工具缺点：服务器单点故障, 容错性差\n\n![image-20210323112415151](image-20210323112415151.png)\n\n### 2.2Git\n\n#### 2.2.1 说明\n\n​ Git 是分布式版本控制系统（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库(本地仓库和远程仓库)。\n\n​ 本地仓库：是在开发人员自己电脑上的 Git 仓库\n​ 远程仓库：是在远程服务器上的 Git 仓库\n\n​ Clone：克隆，就是将远程仓库复制到本地\n​ Push：推送，就是将本地仓库代码上传到远程仓库\n​ Pull：拉取，就是将远程仓库代码下载到本地仓库\n![image-20210323112556941](image-20210323112556941.png)\n\n#### 2.2.2 工作流程\n\n工作流程如下：\n1．从远程仓库中克隆代码到本地仓库\n2．从本地仓库中 checkout 代码然后进行代码修改\n3．在提交前先将代码提交到暂存区\n4．提交到本地仓库。本地仓库中保存修改的各个历史版本\n5．修改完成后，需要和团队成员共享代码时，将代码 push 到远程仓库\n\n![image-20210323112802541](image-20210323112802541.png)\n\n## 3.安装下载\n\n#### 3.1Linux 平台上安装\n\n##### 3.1.1Debian/Ubuntu\n\n```sh\n#1.Debian/Ubuntu Git 安装命令为：\n$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n  libz-dev libssl-dev\n\n$ apt-get install git\n\n$ git --version\ngit version 1.8.1.2\n\n#2.Debian/Ubuntu Git 源码安装方式 最新源码包下载地址：https://git-scm.com/download\n$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n  libz-dev libssl-dev\n\n$ tar -zxf git-1.7.2.2.tar.gz\n$ cd git-1.7.2.2\n$ make prefix=/usr/local all\n$ sudo make prefix=/usr/local install\n```\n\n##### 3.1.2Centos/RedHat\n\n```sh\n#1.命令安装\n$ yum install curl-devel expat-devel gettext-devel \\\n  openssl-devel zlib-devel\n\n$ yum -y install git-core\n\n$ git --version\ngit version 1.7.1\n\n#2.源码安装方式 最新源码包下载地址：https://git-scm.com/download\n$ yum install curl-devel expat-devel gettext-devel \\\n  openssl-devel zlib-\n\n$ tar -zxf git-1.7.2.2.tar.gz\n$ cd git-1.7.2.2\n$ make prefix=/usr/local all\n$ sudo make prefix=/usr/local install\n```\n\n#### 3.2 下载安装\n\n下载链接:https://git-scm.com/download\n\n![image-20210323112938347](image-20210323112938347.png)\n\n安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明 Git 安装成功。\n\n![image-20210323113735053](image-20210323113735053.png)\n\n**Git GUI：Git 提供的图形界面工具\nGit Bash：Git 提供的命令行工具**\n\n## 4.Git 使用步骤\n\n### 4.1 常用的 Git 代码托管服务\n\n```sh\n#前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。\n\ngitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub\n\n码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快\n\nGitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务\n```\n\n### 4.2 以码云为例创建项目\n\n![image-20210323114455106](image-20210323114455106.png)\n\n说明：readme 文件是用来描述这个项目的，里面用 md 格式编写，然后能展示在项目的下面的。\n\n例如：![image-20210323145316575](image-20210323145316575.png)\n\n-\n\n## 5.Git 安装配置\n\n### 5.1git 配置\n\n**Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。**\n\n**这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：**\n\n- **`/etc/gitconfig` 文件：系统中对所有用户都普遍适用的配置。若使用 `git config` 时用 `--system` 选项，读写的就是这个文件。**\n- **`~/.gitconfig` 文件：用户目录下的配置文件只适用于该用户。若使用 `git config` 时用 `--global` 选项，读写的就是这个文件。**\n- **当前项目的 Git 目录中的配置文件（也就是工作目录中的 `.git/config` 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 `.git/config` 里的配置会覆盖 `/etc/gitconfig` 中的同名变量。**\n\n**在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings\\$USER。**\n\n**此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。**\n\n#### 5.1.1 用户信息\n\n**配置个人的用户名称和电子邮件地址：**\n\n```sh\n#当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息\n\n#1.设置用户信息\ngit config --global user.name “itcast”\ngit config --global user.email “kinggm520@163.com”\n\t如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。\n\t如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。这样只有这个项目使用这个信息。\n```\n\n#### 5.1.2 编辑个人信息\n\n```sh\n编辑 git 配置文件:\n$ git config -e    # 针对当前仓库\n\n或者：\n$ git config -e --global   # 针对系统上所有仓库\n```\n\n#### 5.1.3 文本编辑器\n\n```sh\n#设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：\n$ git config --global core.editor emacs\n```\n\n#### 5.1.4 查看配置信息\n\n```sh\n#1.查看配置信息\ngit config --list\ngit config user.name\n```\n\n## 6.Git 工作流程\n\n一般工作流程如下：\n\n- 克隆 Git 资源作为工作目录。\n- 在克隆的资源上添加或修改文件。\n- 如果其他人修改了，你可以更新资源。\n- 在提交前查看修改。\n- 提交修改。\n- 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。\n\n工作流程图：\n\n![image-20210425141221210](image-20210425141221210.png)\n\n## 7. git 图解本地工作区·缓存区·本地仓库·远程仓库\n\n- **工作区：**就是你在电脑里能看到的目录。\n- **暂存区：**英文叫 stage 或 index。一般存放在 **.git** 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n- **版本库：**工作区有一个隐藏目录 **.git**，这个不算工作区，而是 Git 的版本库。\n\n![image-20210423172659919](image-20210423172659919.png)\n\n![image-20210423172723375](image-20210423172723375.png)\n\n- 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage/index），标记为 \"master\" 的是 master 分支所代表的目录树。\n- 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。\n- 图中的 objects 标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。\n- 当对工作区修改（或新增）的文件执行 **git add** 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。\n- 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。\n- 当执行 **git reset HEAD** 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。\n- 当执行 **git rm --cached <file>** 命令时，会直接从暂存区删除文件，工作区则不做出改变。\n- 当执行 **git checkout .** 或者 **git checkout -- <file>** 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。\n- 当执行 **git checkout HEAD .** 或者 **git checkout HEAD <file>** 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。\n\n## 8.Git 创建仓库\n\n#### 8.1 获取 Git 仓库\n\n```sh\n#要使用Git对我们的代码进行版本控制，首先需要获得Git仓库\n#获取Git仓库通常有两种方式：\n1.在本地初始化一个Git仓库\n2.从远程仓库克隆\n```\n\n##### 8.1.1 从本地初始化一个 Git 仓库\n\n```sh\n#1.使用当前目录作为Git仓库，我们只需使它初始化。\ngit init\n\n#2.使用我们指定目录作为Git仓库。\ngit init newrepo\n\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：\n$ git add *.c\n$ git add README\n$ git commit -m '初始化项目版本'\n**注：** 在 Linux 系统中，commit 信息使用单引号 **'**，Windows 系统，commit 信息使用双引号 **\"**。\n所以在 git bash 中 **git commit -m '提交说明'** 这样是可以的，在 Windows 命令行中就要使用双引号 **git commit -m \"提交说明\"**。\n```\n\n![image-20210323150352960](image-20210323150352960.png)\n\n##### 8.1.2 从远程仓库克隆\n\n​ 可以通过 Git 提供的命令从远程仓库进行克隆，将远程仓库克隆到本地\n​ 命令形式为：git clone 远程 Git 仓库地址\n\n```sh\n#我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。克隆仓库的命令格式为：\ngit clone <repo>\n\n#如果我们需要克隆到指定的目录，可以使用以下命令格式：\ngit clone <repo> <directory>\n\n#执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n$ git clone git://github.com/schacon/grit.git mygrit\n```\n\n![image-20210323151342389](image-20210323151342389.png)\n\n## 9. Git 基本操作\n\n**Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。**\n\n![image-20210426083747674](image-20210426083747674.png)\n\n### 9.1 git add(文件加入暂存区)\n\n**git add** 命令可将该文件添加到暂存区。\n\n**1.添加一个或多个文件到暂存区**\n\n```sh\ngit add [file1] [file2] ...\n```\n\n![image-20210426084951892](image-20210426084951892.png)\n\n**2.添加指定目录到暂存区，包括子目录**\n\n```sh\ngit add [dir]\n```\n\n**3.添加当前目录下的所有文件到暂存区**\n\n```sh\ngit add .\n```\n\n### 9.2 git status(查看暂存区文件状态)\n\n**git status 命令用于查看在你上次提交之后是否有对文件进行再次修改。**\n\n```sh\n#查看的比较详细，其中绿色的表示提交的加入暂存区的文件\ngit status\n```\n\n![image-20210426085755483](image-20210426085755483.png)\n\n**git status -s 通常我们使用 -s 参数来获得简短的输出结果**\n\n```sh\ngit status -s\n```\n\n![image-20210426085947648](image-20210426085947648.png)\n\n### 9.3 git diff (比较文件不同)\n\n**1.git diff：是查看 workspace 与 index 的差别的。**\n\n```sh\ngit diff\n```\n\n我们新建文件 6.txt 然后加入 11111 文件然后使用 git add .提交到暂存区,然后在文件后面加上 2222，在使用 git diff 命令\n\n修改前：\n\n![image-20210426102530373](image-20210426102530373.png)\n\n修改后：\n\n![image-20210426102827982](image-20210426102827982.png)\n\n结果：\n\n![image-20210426103012238](image-20210426103012238.png)\n\n```sh\n#结果说明：\n第一行表示结果为git格式的diff\ndiff --git a/6.txt b/6.txt\n进行比较的是,a版本的6(即变动前)和b版本的6(即变动后)。\n\n第二行表示两个版本的git哈希值和最后的六位数字是对象的模式\nindex 56b6510..a05a48c 100644\nindex区域的56b6510对象,与工作目录区域的a05a48c对象进行比较 后面100代表普通文件，644代表文件具有的权限（同linux文件权限）\n\n第三四行表示进行比较的两个文件\n--- a/6.txt\n+++ b/6.txt\n\"-“表示变动前的版本，”+++\"表示变动后的版本。\n\n第五行表示代码变动的位置用两个@作为起首和结束\n@@ -1 +1 @@\n\"-1,7″分成三个部分：减号表示第一个文件(即f1)，\"1″表示第1行，“7″表示连续7行。\n合在一起，就表示下面是第一个文件第1行做了开始\n同样的，”+1″表示变动后，成为第二个文件从第1行开始\n\n第三部分是变动的具体内容\n-11111\n\\ No newline at end of file\n+111112222\n\\ No newline at end of file\n变动的行，每一行最前面的标志位：“-”代表第一个文件删除的行用红色表示，“+”表示第二个文件新增的行用绿色表示，如果是白色无标志表示该行无变动。\n\n\n\n```\n\n**2.git diff --cached 或 git diff --staged [file] 是查看 index 与 local repositorty 的差别的。**\n\n**3.git diff HEAD：是查看 workspace 和 local repository 的差别的。（HEAD 指向的是 local repository 中最新提交的版本**\n\n**4.$ git diff test**\n**上面的命令会显示你当前工作目录与另外一个叫’test’分支的差别。**\n\n**5.$ git diff HEAD -- ./lib**\n**上面这条命令会显示你当前工作目录下的 lib 目录与上次提交之间的差别(或者更准确的 说是在当前分支)。**\n\n**6.$ git diff --stat**\n**上面的命令会统计一下有哪些文件被改动，有多少行被改动**\n\n### 9.4 git commit(提交到版本库)\n\n**1.git commit 命令将暂存区内容添加到本地仓库中。**\n\n```sh\n#提交暂存区到本地仓库中:[message] 可以是一些备注信息。\ngit commit -m [message]\n```\n\n**2.提交多个指定文件到仓库区：**\n\n```sh\n$ git commit [file1] [file2] ... -m [message]\n```\n\n**3.-a 参数设置修改文件后不需要执行 git add 命令，直接来提交**\n\n```sh\n#加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对修改和删除文件有效， 新文件还是要 git add，不然就是 untracked 状态\n$ git commit -a -m [message]\n```\n\n**4.Git 工作目录下文件的状态**\n\n- **#Git 工作目录下的文件存在两种状态：**\n- **untracked 未跟踪（未被纳入版本控制）**\n- **tracked 已跟踪（被纳入版本控制）**\n- **Unmodified 未修改状态**\n- **Modified 已修改状态**\n- **Staged 已暂存状态**\n- **这些文件的状态会随着我们执行 Git 的命令发生变化**\n\n### 9.5 git reset\n\n**git reset 并不会产生 commits 它只是改变了当前 HEAD 指向的 commits。**\n\n#### 9.5.1 git reset --soft\n\n```sh\n#跳转到指定版本、不还原缓存区、不还原工作区。\n$ git  reset --soft 版本号          # 整个项目回退到指定版本\n\n\n$ git reset HEAD^            # 整个项目回退所有内容到上一个版本\n$ git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本\n\n$ git reset HEAD~1           # 整个项目回退所有内容到上一个版本\n$ git reset HEAD~1 hello.php # 回退 hello.php 文件的版本到上一个版本\n\n\n```\n\n#### 9.5.2 git reset --mixed\n\n```sh\n# --mixed 为默认，  跳转到指定版本、还原缓存区、不还原工作区。\n$ git  reset  版本号          # 整个项目回退到指定版本\n```\n\n#### 9.5.3 git reset --hard\n\n```sh\n# --head 跳转到指定版本、还原缓存区、还原工作区（原理：将本库的头指针全部重置到指定版本）\nHEAD 就是当前活跃分支的游标。形象的记忆就是：你现在在哪儿，HEAD 就指向哪儿，所以 Git 才知道你在那儿！ 不过 HEAD\n并非只能指向分支的最顶端（时间节点距今最近的那个），实际上它可以指向任何一个节点，它就是 Git 内部用来追踪当前位置的东东。\n\n$ git  reset  --hard 版本号\n```\n\n### 9.6 git rm 命令\n\n##### 9.6.1 git rm 文件名字(删除暂存区文件和工作区文件)\n\n```sh\n#1. git rm 文件名字 将文件从暂存区和工作区中删除,注意文件夹要加 git rm -r 文件\n删除完工作区文件后查询状态显示删除,因为删除的是暂存区数据所以,这时候需要提交操作才能提交到本地仓库影响到本地仓库\ngit rm <file>\n```\n\n##### 9.6.2 git rm --cached 文件名字(删除暂存区文件)\n\n```sh\ngit rm 文件名字 --cached\n```\n\n### 9.7git mv 命令\n\n#### 9.7.1 git mv oldFile new File(移动或重命名)\n\n```sh\n#将修改指定文件名字\ngit mv [file] [newfile]\n```\n\n#### 9.7.2 git mv -f oldFile new File(当文件名已经存在时候强制移动或重命名)\n\n```sh\n#注意这时候这个文件会覆盖原本的文件\ngit mv -f [file] [newfile]\n```\n\n### 9.8 git remote 命令\n\n#### 9.8.1 git remote(查看远端仓库)\n\n​ 如果想查看已经配置的远程仓库服务器，可以运行 **git remote** 命令。 它会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字\n\n```sh\n#查看远端仓库\ngit remote\n\norigin: Git里面的origin就是一个名字，它是在你clone一个托管在Github上代码库时，git为你默认创建的指向这个远程代码库的标签。\n```\n\n![image-20210330221453369](image-20210330221453369.png)\n\n```sh\n#看详细版本信息\ngit remote -v\n```\n\n![image-20210330221648280](image-20210330221648280.png)\n\n#### 9.8.2git remote rm(移除无效的远程仓库)\n\n如果因为一些原因想要移除一个远程仓库 ，可以使用 git remote rm\n\n```sh\n#删除远端仓库 注意：此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库\ngit remote rm 仓库名字\n```\n\n![image-20210330221900433](image-20210330221900433.png)\n\n#### 9.8.3 git remote add (添加远程仓库)\n\n运行 git remote add < shortname> < url> 添加一个新的远程 Git 仓库，同时指定一个可以引用的简写\n\n```sh\n#添加远端仓库,仓库名称默认是origin 当我们添加远端仓库时候可以指定这个仓库名字 git remote add 仓库名字别名 仓库地址\ngit remote add 仓库名字(仓库起一个别名) 仓库地址url\n例子:\ngit remote add origin https://gitee.com/qaqxidu/demo1.git\n```\n\n![image-20210330222027857](image-20210330222027857.png)\n\n#### 9.8.34 (git remote rename)重命名远程仓库\n\n```sh\n# 修改仓库名\ngit remote rename old_name new_name\n```\n\n### 9.9 git fetch/pull/push\n\n抓取：\n\n​ git fetch 是从远程仓库获取最新版本到本地仓库，不会自动 merge\n\n```sh\n# 1.抓取到本地仓库\ngit fetch origin master\n#2. 进行合并 合并后工作区才回出现拉取下来的文件\ngit merge origin/master\n```\n\n拉取：\n\ngit pull 是从远程仓库获取最新版本并 merge 到本地仓库\n\n```sh\n#命令（本地工作区直接最出现拉取下来的文件）下面命令表示，取回 origin/master 分支，再与本地的 master 分支合并,如果远程分支是与当前分支合并，则冒号后面的部分可以省略。同理推送时候也是\ngit pull origin master:master\n\n**注意：**如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories\n当执行git中的“git pull origin master –allow-unrelated-histories”命令时，会出现“ couldn’t find remote ref –allow-unrelated-histories”的错误，\n输入如下命令即可解决：\ngit pull --rebase origin master\n\n```\n\n概念说明:\n\n```sh\n#你clone本地仓库的时候被clone的远端仓库默认被称为 origin。 所以如果你想向/从这个远端仓库push/pull 的时候，用 origin 指代这个远端仓库。\n你可以在 .git/config 之中进行修改\n事实上 git push origin master 的意思是 git push origin master:master （将本地的 master 分支推送至远端的 master 分支，如果没有就新建一个）\n```\n\n推送:\n\n您可以将新的更改推`master`回到`origin`：\n\n```sh\n#命令形式：git push [remote-name] [branch-name]\ngit push origin master\n```\n\n## 10.Git 分支管理\n\n​ **几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。**\n\n​ **有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。**\n\n#### 10.1 查看分支命令\n\n```sh\n#1.列出所有本地分支 其中绿色表示单前分支是master\ngit branch\n\n#2.列出所有远程分支(其中前面带origin的就是远程分支)\ngit branch -r\n\n#3.列出所有本地分支和远程分支\ngit branch -a\n```\n\n![image-20210330225142644](image-20210330225142644.png)\n\n#### 10.2 创建分支\n\n```sh\n#创建分支\ngit branch 分支名字\n```\n\n![image-20210330225448687](image-20210330225448687.png)\n\n#### 10.3 切换分支\n\n```sh\n#切换分支切换分支到master2,下图表示当前分支是在master上然后我们切换到master2上\n#当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\ngit checkout master2\n\n#表示创建master3分支并切换到这个分支\ngit checkout -b master3\n```\n\n![image-20210330225704543](image-20210330225704543.png)\n\n#### 10.4 删除分支\n\n```sh\n#删除指定分支 不能删除当前分支\ngit branch -d 删除的分支名字\n\n#如果要删除的分支中进行了一些开发动作（提交到远端），此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D\ngit branch -D 删除的分支名字\n\n#在删除远端的一个分支：\ngit push origin :newBranch (分支名前的冒号代表删除)\n或 git push origin --delete 分支名字\n```\n\n#### 10.5 合并分支\n\n```sh\n#合并分支\ngit merge 当前要合并的分支名字\n\n说明:\n有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决\n#一般建议在做这样的操作之前, 新建一个 branch 当作备份. 但就算是你不备份, git reflog 也会是最后一道强大的防护网, 通过它能够回到最近的一系列 repo 的状态上.\n```\n\n#### 10.6 推送至远程仓库分支\n\n```sh\n#把master2分支推送到远端仓库\ngit push origin master2\n```\n\n![image-20210330225927391](image-20210330225927391.png)\n\n#### 10.7 合并分支\n\n```sh\n#合并分支\ngit merge 当前要合并的分支名字\n\n说明:\n有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决\n#建议在做这样的操作之前, 新建一个 branch 当作备份. 但就算是你不备份, git reflog 也会是最后一道强大的防护网, 通过它能够回到最近的一系列 repo 的状态上.\n```\n\n#### 10.8 综合使用\n\n​ **因为创建、合并和删除分支非常快，所以 Git 鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。**\n\n**所以我们一般都是在新建自己的分支然后开发完成后把自己分支合并到主的 master 分支上**\n\n```sh\n#1.首先，我们创建dev分支，然后切换到dev分支\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n\n#2.git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev\n$ git checkout dev\nSwitched to branch 'dev'\n\n#3.然后，用git branch命令查看当前分支：\n$ git branch\n* dev\n  master\n\n#4.git branch命令会列出所有分支，当前分支前面会标一个*号。\n#然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\nCreating a new branch is quick.\n\n#5.然后提交：\n$ git add readme.txt\n$ git commit -m \"branch test\"\n[dev fec145a] branch test\n 1 file changed, 1 insertion(+)\n\n#6.现在，dev分支的工作完成，我们就可以切换回master分支：\n$ git checkout master\nSwitched to branch 'master'\n\n#7.切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\ngit-br-on-master\n\n#8.现在，我们把dev分支的工作成果合并到master分支上：\n$ git merge dev\nUpdating d17efd8..fec145a\nFast-forward\n readme.txt |    1 +\n 1 file changed, 1 insertion(+)\n\n#9.git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n```\n\n## 11.查看提交历史\n\n**Git 提交历史一般常用两个命令：**\n\n- **git log** - 查看历史提交记录。\n- **git blame <file>** - 以列表形式查看指定文件的历史修改记录。\n\n### 11.1 git log\n\n#### 11.1.1 git log\n\n```sh\n#命令列出历史提交记录如下默认是根据时间从上往下倒序\ngit log\n\n#根据时间倒序查看\ngit log --reverse\n```\n\n#### 11.1.2 git log --oneline(简洁版日志)\n\n```sh\n#查看历史记录的简洁的版本。\ngit log --oneline\n```\n\n![image-20210426142940501](image-20210426142940501.png)\n\n#### 11.1.2 git log --graph(开启了拓扑图选项)\n\n```sh\n#开启了拓扑图选项\ngit log --graph\n```\n\n![image-20210426143200275](image-20210426143200275.png)\n\n#### 11.1.13 git log --author(查看某个账号的日志记录)\n\n```sh\n#查看指定用户提交记录\ngit log --author\n例子：git log --author 15036563343@139.com\n```\n\n#### 11.1.14. git reflog\n\n```sh\n#可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）\n```\n\n### 11.2 git blame\n\n如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：\n\n```sh\ngit blame <file>\n```\n\n![image-20210426143614939](image-20210426143614939.png)\n\n## 12. Git 标签\n\n**标签介绍**\n\n​ **发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。**\n\n**-a 选项意为\"创建一个带注解的标签\"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。**\n\n```sh\nGit有commit，为什么还要引入tag？\n\n\"请把上周一的那个版本打包发布，commit号是6a5819e…\"\n\n\"一串乱七八糟的数字不好找！\"\n\n如果换一个办法：\n\n\"请把上周一的那个版本打包发布，版本号是v1.2\"\n\n\"好的，按照tag v1.2查找commit就行！\"\n\n所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n```\n\n### 12.1 列出所有标签\n\n```sh\n#列出所有tag\n git tag\n```\n\n### ![image-20210426165612095](image-20210426165612095.png)\n\n### 12.2 查看标签信息\n\n```sh\n # 查看tag信息\n git show [tag]\n```\n\n![image-20210421134607934](image-20210421134607934.png)\n\n### 12.3 创建新标签\n\n```sh\n#新建一个tag\ngit tag -a <tagname> -m \"runoob.com标签\"\n\n#如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。\ngit tag -a v0.9 -m \"runoob.com标签\" 版本号\n```\n\n![image-20210421134701333](image-20210421134701333.png)\n\n### 12.4 将标签推送至远程仓库\n\n```sh\n#提交指定tag\ngit push origin [tag]\n```\n\n### 12.5 检出标签\n\n```sh\n#新建一个分支，指向某个tag\ngit checkout -b [branch] [tag]\n```\n\n### 12.6 删除标签\n\n```sh\n# 删除本地tag\n$ git tag -d [tag]\n# 删除远程tag\n$ git push origin :refs/tags/[tag]\n```\n\n## 13.HEAD 说明\n\n```sh\n1.在[版本回退])里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。\n一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点：\n\n2.每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n3.你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n```\n\n## 14.解决冲突问题\n\n### 14.1 说明\n\n```sh\n#复制代码提交时发生冲突,你能解释冲突是如何产生的吗?你是如 何解决的?\n\n#方法1\n1.如果开发时候远端修改了一个文件的第一行,而本地修改了一个文件第二行,那么可以直接用本地分支和远端分支进行合并就好了。\n如果远端修改第一行数据，本地也修改第一行数据,那么合并就会冲突,这时候需要手动进行删除分隔符然后手动合并。\n\n#方法2\n2.发生冲突，也可以使用命令:\n通过git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改； 通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突； 通过git stash pop命令，把保存在栈区的修改部分合并到最新的工作空间中,然后在提交\n一般什么情况下 我们会用到git stash命令？\n命令git stash是把工作区修改的内容存储在栈区。\n#说明：如果本地修改的这个文件第二行,而远端和修改这个文件的第二行,那么我么即使把本地第二行做的修改提交到stash中然后把远端第二行更新下来,然后在把栈的数据合并到本地时候,这时候也会提示合并冲突也需要进行手动修改.\n\ngit stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。\ngit stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。\ngit stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。\ngit stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。\n\n以下几种情况会使用到它：\n解决冲突文件时，会先执行git stash，然后解决冲突； 遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后 通过git stash pop取出栈区的内容继续开发； 切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换\n\n#3.强行冲掉之前的分支,用本地文件强行覆盖远程文件\ngit push origin [分支名称] --force\n\n#4.如果使用merge我们提交到了远端了怎么撤回?\n 步骤1：先回退本地版本\n git reset --soft 版本号\n 步骤2：使用--force强行提交会用本地版本覆盖远端的版本\n git push origin 分支 --force\n\n```\n\n## 15.常见错误解决\n\n### 1.git push -u 和 git branch --set-upstream-to 区别\n\n```sh\n# git push -u origin/master master\n表示先把远程分支origin/master和本地分支master建立一个关联通道,然后在执行 push操作\n\n# git branch  --set-upstream-to=origin/master master\n表示把远程分支origin/master 和本地分支建立一个关联\n\n也就是：git push -u origin mybranch1 相当于 git push origin mybranch1 + git branch --set-upstream-to=origin/mybranch1 mybranch1\n当然只有我们有多个远程仓库或者,没有关联远程仓库时候才会这样进行操作,因为这样先执行本地分支和远程分支关联,否则会提示远程分支为被跟踪。\n```\n\n解释说明：\n\n​ 一般只有同时存在多个远程仓库时才会用到--set-upstream。每个 git branch 可以有个对应的 upstream。假设你有两个 upstream，分别叫 server1 和 server2，本地 master branch 的 upstream 是 server1 上的 master，那么当你不带参数直接输入 git pull 或者 git push 时，默认是对 server1 进行 pull/push。如果你成功运行\"git push -u server2 master\"，那么除了本地 branch 会被 push 到 server2 之外，还会把 server2 设置成 upstream。\n\n​ $ git push -u origin master\n\n​ 如果当前分支与多个主机存在追踪关系，那么这个时候-u 选项会指定一个默认主机，这样后面就可以不加任何参数使用 git push。\n\n​ 上面命令将本地的 master 分支推送到 origin 主机，同时制定 origin 为默认主机,后面可以不加任何参数使用 git push 了\n不带任何参数 git push 默认只推送当前分支，这种叫做 simple 方式此外,还有一种 matching 的方式,会推送所有对应的远程分支的本地分支，git2.0 之前默认采用的是 matching 方法,现在默采用 simple 方式\n","tags":["版本控制"],"categories":["版本控制"]},{"title":"Vue异步路由和路由懒加载","url":"/2021/07/16/Vue/Vue异步路由和路由懒加载/","content":"\n### 一、 异步组件\n\n#### 1. 什么是异步组件\n\n异步组件就是定义的时候什么都不做，只在组件需要渲染（组件第一次显示）的时候进行加载渲染并缓存，缓存是以备下次访问。\n\n#### 2. 实现异步组件的方法\n\n- **resolve** 方法引入异步组件\n\n```js\n<script>\nexport default {\n  components:{\n    \"One-com\":resolve=>(['./one'],resolve)\n  },\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  }\n}\n</script>\n```\n\n- **import** 方法\n\n```js\n<script>\nconst One = ()=>import(\"./one\");\nexport default {\n  components:{\n    \"One-com\":One\n  },\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  }\n}\n</script>\n```\n\n### 二、路由懒加载\n\n#### 1. 什么是路由懒加载？\n\n- 延迟加载或按需加载，在需要的时候的时候进行加载并缓存下来，方便下次使用；\n\n#### 2. 实现路由懒加载的方式\n\n- **resolve** 方法\n\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'HelloWorld',\n      component: (resolve) => require(['@/components/HelloWorld'], resolve),\n    },\n  ],\n})\n```\n\n- **import** 方法\n\n```js\n// 下面2行代码，没有指定webpackChunkName，每个组件打包成一个js文件。\nconst ImportFuncDemo1 = () => import('../components/ImportFuncDemo1')\nconst ImportFuncDemo2 = () => import('../components/ImportFuncDemo2')\n// 下面2行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。\n// const ImportFuncDemo = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo')\n// const ImportFuncDemo2 = () => import(/* webpackChunkName: 'ImportFuncDemo' */ '../components/ImportFuncDemo2')\nexport default new Router({\n  routes: [\n    {\n      path: '/importfuncdemo1',\n      name: 'ImportFuncDemo1',\n      component: ImportFuncDemo1,\n    },\n    {\n      path: '/importfuncdemo2',\n      name: 'ImportFuncDemo2',\n      component: ImportFuncDemo2,\n    },\n  ],\n})\n```\n\n- **webpack** 的 **require.ensure()** 方法\n\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'HelloWorld',\n      component: (resolve) =>\n        require.ensure(\n          [],\n          () => resolve(require('../components/HelloWorld')),\n          'demo'\n        ),\n    },\n  ],\n})\n```\n","tags":["前端","vue-router"],"categories":["前端","vue"]},{"title":"Gulp 基础知识总结","url":"/2021/07/14/打包工具/gulp/","content":"\n# Gulp 基础知识总结\n\n[参考链接](https://www.bilibili.com/video/BV1yA411s72G?p=1)\n\n## 一、了解 gulp\n\n### 1. gulp 是什么\n\n- 是一个前端自动化打包构建工具；\n  - 打包：就是把文件进行压缩、整合、移动等一系列操作；\n\n### 2. 常见的前端打包构建工具\n\n- **gulp**：它是基于 **流** 的打包构建工具；\n- **webpack**：它是基于 **js** 文件的打包构建工具；\n\n### 3. 什么是流\n\n- **流文件: 流**\n  - 是一种文件传输的格式；\n  - 一段一段的文件传输；.\n- **流格式: 流**\n  - 是从头到尾的一个过程，相当于链式调用的结构过程；\n  - 需要从 源 开始一步一步经过加工，每一个步骤需要依赖上一步的结果，最终给出一个完整的结果；\n- **gulp** 是基于流格式的一种打包构建工具；\n\n### 4. gulp 的依赖环境\n\n- 依赖于 **node** 环境进行开发；\n- 底层封装的内容就是 **node** 里面的读写文件（ **fs** 模块儿）；\n\n### 5. gulp 的作用\n\n- **css** 文件：可以进行压缩、转码（自动添加解决兼容性的前缀）；\n- **js** 文件： 可以进行压缩、转码（将 ES6 的语法转换成 ES5 的语法）；\n- **html** 文件：压缩、转码（通过配置项自定义如何处理 **html** 文件）；\n- 对于静态资源文件的处理；\n- 对于第三方文件的处理；\n- ……\n\n### 6. gulp 的安装检测\n\n- 是一个 **JavaScript** 相关的工具，可以直接使用 npm 进行安装，需要安装再你的电脑环境里面, 一次安装多次使用，使用命令：\n\n  `npm install --global gulp`\n\n- 检测 **gulp**：\n\n  `gulp --version` 检测出 **gulp cli 2.3.0** 版本号代表 **gulp@4** 安装成功，检测出 **gulp 3.9.1** 代表 **gulp@3** 安装成功；\n\n## 二、使用 gulp 的准备工作\n\n### 1. 首先准备一个项目\n\n- 确定好目录结构\n\n  - gulp-demo\n    - src&emsp;&emsp;&emsp;&emsp;源码目录\n      - pages&emsp;&emsp;&emsp;html 文件目录\n      - css&emsp;&emsp;&emsp;&emsp;css 文件目录\n      - js&emsp;&emsp;&emsp;&emsp;&emsp;js 文件目录\n      - sass&emsp;&emsp;&emsp;&emsp;scss 文件目录\n      - images&emsp;&emsp;&emsp;图片\n      - videos&emsp;&emsp;&emsp;视频\n      - audios&emsp;&emsp;&emsp;音频\n      - lib&emsp;&emsp;&emsp;&emsp;&emsp;第三方插件\n      - fonts&emsp;&emsp;&emsp;&emsp;字体图标\n\n- 准备一个 gulpfile.js 的文件\n\n  - gulpfile.js 是 gulp 进行打包的依据，每一个项目需要一个 gulpfile.js，在这个文件里面进行本项目的打包配置；\n  - gulp 在运行的时候, 会自动读取 gulpfile.js 文件里面的配置，按照你再 **gulpfile.js** 文件里面的配置进行打包工作；\n  - 注意: **直接写在项目根目录, 和 src 同级**；\n\n- 项目里面再次安装 gulp\n\n  - 注意: **项目里面的 gulp 是以第三方模块的形式出现的**；\n\n  - 专门给你提供配置打包流程的 API 的，每一个项目都要安装一次，安装命令如下：\n\n    `npm install gulp -D`\n\n- 在 **gulpfile.js** 里面书写配置文件\n\n  - 编写该项目的打包流程，写完以后, 按照打包流程去执行 gulp 指令运行 gulpfile.js 文件；\n\n- **package.json** 记录的第三方依赖\n\n  - **dependencies**：表示项目的 **项目依赖**，比如 **jquery, swiper**，指项目运行需要用到的内容, 将来上线以后也需要用到的内容；\n  - **devDependencies**：表示项目的 **开发依赖**，比如 **gulp**，指项目开发阶段需要用到的内容, 将来上线以后不需要用到的依赖；\n  - **gulp** 第三方包最好是放在 **devDependencies**，在你安装第三方依赖的时候, 书写`$ npm install --dev` 包名，就会把依赖项记录在 **devDependencies**\n\n## 三、认识 gulp 常用的 API\n\n前提：需要在项目中安装了 gulp 第三方后，通过`const xxx = require('xxx')`使用;\n\n### 1. gulp.task()\n\n- 语法：**gulp.task(任务名称, 任务处理函数)**;\n\n- 作用：创建一个基于流的任务；\n\n- 例子：\n\n  ```js\n  gulp.task('htmlHandler', function () {\n    // 找到 html 源文件, 进行压缩, 打包, 放入指定目录\n  })\n  ```\n\n### 2. gulp.src()\n\n- 语法：**gulp.src(路径信息)**；\n\n- 作用：找到源文件；\n\n- 书写方式：\n\n  ```js\n  gulp.src('./a/b.html') // 2-1. -> 找到指定一个文件\n  gulp.src('./a/*.html') // 2-2. -> 找到指定目录下, 指定后缀的文件\n  gulp.src('./a/**') // 2-3. -> 找到指令目录下的所有文件\n  gulp.src('./a/** /*') // 2-4. -> 找到 a 目录下所有子目录里面的所有文件\n  gulp.src('./a/** /*.html') // 2-5. -> 找到 a 目录下所有子目录里面的所有 .html 文件\n  ```\n\n### 3. gulp.dest()\n\n- 语法：**gulp.dest(路径信息)**；\n- 作用：把一个内容放入指定目录内；\n- 例子：**gulp.dest('./abc')**， 把他接收到的内容放到 **abc** 目录下；\n\n### 4. gulp.watch()\n\n- 语法：**gulp.watch(路径信息, 任务名称)**；\n- 作用：监控指定目录下的文件, 一旦发生变化, 重新执行后面的任务；\n- 例子: `gulp.watch('./src/pages/*.html', htmlHandler)` 当指定目录下的 html 文件发生变化, 就会执行 htmlHandler 这个任务;\n\n### 5. gulp.series()\n\n- 语法：**gulp.series(任务 1, 任务 2, 任务 3, ...)**；\n- 作用: 逐个执行多个任务, 前一个任务结束, 第二个任务开始；\n\n### 6. gulp.parallel()\n\n- 语法：**gulp.parallel(任务 1, 任务 2, 任务 3, ...)**；\n- 作用：**并行**开始多个任务（不能控制结束的顺序）\n\n### 7. pipe()\n\n- 管道函数，所有的 **gulp API** 都是基于**流**，接收当前流, 进入下一个流过程的管道函数；\n- 例子：`gulp.src().pipe(压缩任务).pipe(转码).pipe(gulp.dest('abc'))`；\n\n## 四、gulp 常用插件和使用\n\n### 1. gulp-cssmin\n\n- 下载：`npm i gulp-cssmin -D`；\n\n- 导入：`const cssmin = require('gulp-cssmin')`\n\n- 导入以后得到一个处理流文件的函数，直接再管道函数里面执行就好了\n\n- 配置如下：\n\n  ```js\n  /** gulpfile.js */\n  /* \n    因为 gulp 是依赖于 node 环境运行的\n    将来的运行也是以 node 为基础运行的\n    书写 gulpfile.js 文件就按照 node 的模块化语法进行书写(CommonJS) \n  */\n  const gulp = require('gulp')\n  // 1. 导入 gulp-cssmin\n  const cssmin = require('gulp-cssmin')\n  /*\n    创建一个打包 css 的任务\n    gulp@3 的标准书写语法：\n  */\n  gulp.task('cssHandler', function () {\n    // 需要捕获到该任务的结束, 需要把这个流 return 出去,\n    // task 就会处理流\n    return gulp\n      .src('./src/css/*.css') // 1-1. 找到源文件\n      .pipe(cssmin()) // 1-2. 压缩文件\n      .pipe(gulp.dest('./dist/css/')) // 1-3. 把压缩好的内容放在指定目录下\n  })\n  /*\n    gulp@4 的标准书写语法：需要在 gulpfile.js 文件里面把这个函数名导出\n  */\n  const cssHandler = function () {\n    return gulp\n      .src('./src/css/*.css')\n      .pipe(cssmin())\n      .pipe(gulp.dest('./dist/css/'))\n  }\n  // 导出任务\n  module.exports.cssHandler = cssHandler\n  ```\n\n- 执行指令：`gulp cssHandler`之后就会将 **./src/css/** 下的 **css** 文件压缩后输出到 **./dist/css/** 文件夹下；\n\n### 2. gulp-autoprefixer\n\n- 下载：`npm i gulp-autoprefixer -D`；\n- 导入：`const autoPrefixer = require('gulp-autoprefixer')`；\n- 导入以后得到一个处理流文件的函数，直接再管道函数里面使用, 需要传递参数；\n- 配置需要兼容的浏览器及版本{ browsers: [要兼容的浏览器] }；\n\n### 3. gulp-sass\n\n- 下载：`npm i gulp-sass -D`；\n  - 很容易报错, 基本下载不成功，因为 **gulp-sass** 依赖另一个第三方, **node-sass**；\n  - 解决: 给 **node-sass** 单独配置一个下载地址：\n    - `set SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/`\n    - `npm i node-sass -D`\n    - `npm i gulp-sass -D`\n- 导入：`const sass = require('gulp-sass')`；\n- 导入以后得到一个可以处理流文件的函数, 直接再管道函数里面执行就可以了；\n\n### 4. gulp-uglify\n\n- 用来压缩 **js** 文件的；\n- 下载：`npm i -D gulp-uglify`；\n- 导入：`const uglify = require('gulp-uglify')`；\n- 导入以后得到一个可以处理流文件的函数，直接再管道函数中使用就可以了；\n- 注意: 你不能写 ES6 语法, 一旦有了 ES6 语法就会报错；\n\n### 5. gulp-babel\n\n- 专门进行 **ES6** 转 **ES5** 的插件；\n- **gulp-babel** 的版本：\n  - **gulp-babel@7**: 大部分使用再 gulp@3 里面；\n  - **gulp-babel@8**: 大部分使用再 gulp@4 里面；\n- 下载：\n  - **gulp-babel** 需要依赖另外两个包, 我们要一起下载；\n  - 另外两个包: **@babel/core @babel/preset-env**；\n- 导入：\n  - 只要导入一个包就够了, 他会自动导入另外两个包;\n  - `const babel = require('gulp-babel')`;\n- 导入以后得到一个可以处理流文件的函数，直接再管道函数中使用就可以了；\n\n### 6. gulp-htmlmin\n\n- 作用：是用来处理 **html** 文件的 gulp 插件；\n\n- 下载：`npm i -D gulp-htmlmin`；\n- 导入: const htmlmin = require('gulp-htmlmin')；\n- 导入以后得到一个可以处理流文件的函数，直接再管道函数中使用，需要传递参数；\n\n### 7. del\n\n- 下载：`npm i -D del；；\n- 作用: 删除文件目录；\n- 导入：`const del = require('del')`；\n- 导入以后得到一个函数, 直接使用传递参数就可以了；\n\n### 8. gulp-webserver\n\n- 作用: 启动一个基于 **node** 书写的服务器；\n- 下载：`npm i -D gulp-webserver`；\n- 导入：`const webserver = require('gulp-webserver')`；\n- 导入以后得到一个处理流文件的函数，我们再管道函数内调用就可以了, 需要传递参数；\n\n### 9. gulp-file-include\n\n- 作用：在一个 html 页面里面导入一个 **html 片段**；\n- 下载：`npm i -D gulp-file-include`；\n- 导入：`const fileInclude = require('gulp-file-include')`；\n- 导入以后得到一个处理流文件的函数，在管道函数内调用就可以了, 需要传递参数；\n\n### 10. 整合一下常用插件\n\n```js\n/** gulpfile.js */\n// 0. 导入第三方gulp\nconst gulp = require('gulp')\n// 0-2. 导入 gulp-cssmin\nconst cssmin = require('gulp-cssmin')\n// 0-3. 导入 gulp-autoprefixer\nconst autoPrefixer = require('gulp-autoprefixer')\n// 0-4. 导入 gulp-sass\nconst sass = require('gulp-sass')\n// 0-5. 导入 gulp-uglify\nconst uglify = require('gulp-uglify')\n// 0-6. 导入 gulp-babel\nconst babel = require('gulp-babel')\n// 0-7. 导入 gulp-htmlmin\nconst htmlmin = require('gulp-htmlmin')\n// 0-8. 导入 del\nconst del = require('del')\n// 0-9. 导入 gulp-webserver\nconst webserver = require('gulp-webserver')\n// 0-10. 导入 gulp-file-include\nconst fileInclude = require('gulp-file-include')\n\n// 1. 创建任务\n// 1-1. 创建一个打包 css 的任务\nconst cssHandler = function () {\n  return gulp\n    .src('./src/css/*.css') // 1. 找到内容\n    .pipe(autoPrefixer()) // 2. 自动添加前缀\n    .pipe(cssmin()) // 3. 压缩\n    .pipe(gulp.dest('./dist/css/')) // 4. 放到指定目录\n}\n\n// 1-2. 创建一个打包 sass 文件的任务\nconst sassHandler = function () {\n  return gulp\n    .src('./src/sass/*.scss')\n    .pipe(sass())\n    .pipe(autoPrefixer())\n    .pipe(cssmin())\n    .pipe(gulp.dest('./dist/sass/'))\n}\n\n// 1-3. 创建一个打包 js 文件的任务\nconst jsHandler = function () {\n  return gulp\n    .src('./src/js/*.js') // 1. 找到 js 文件\n    .pipe(\n      babel({\n        // babel@7, presets: ['es2015']\n        presets: ['@babel/env'],\n      })\n    )\n    .pipe(uglify())\n    .pipe(gulp.dest('./dist/js/'))\n}\n\n// 1-4. 创建一个打包 html 文件的任务\nconst htmlHandler = function () {\n  return gulp\n    .src('./src/pages/*.html')\n    .pipe(\n      fileInclude({\n        // 根据你的配置导入对应的 html 片段\n        prefix: '@-@', // 你自定义的一个标识符\n        basepath: './src/components', // 基准目录, 你的组件文件都在哪一个目录里面\n      })\n    )\n    .pipe(\n      htmlmin({\n        // 通过你配置的参数来进行压缩\n        // collapseWhitespace: true, // 表示移出空格\n        removeEmptyAttributes: true, // 表示移出空的属性(仅限于原生属性)\n        collapseBooleanAttributes: true, // 移出 checked 类似的布尔值属性\n        removeAttributeQuotes: true, // 移出属性上的双引号\n        minifyCSS: true, // 压缩内嵌式 css 代码(只能基本压缩, 不能自动添加前缀)\n        minifyJS: true, // 压缩内嵌式 JS 代码(只能基本压缩, 不能进行转码)\n        removeStyleLinkTypeAttributes: true, // 移出 style 和 link 标签上的 type 属性\n        removeScriptTypeAttributes: true, // 移出 script 标签上默认的 type 属性\n      })\n    )\n    .pipe(gulp.dest('./dist/pages/'))\n}\n\n// 1-5. 创建一个打包 images 文件的任务\nconst imgHandler = function () {\n  return gulp.src('./src/images/**').pipe(gulp.dest('./dist/images/'))\n}\n\n// 1-6. 创建一个打包 videos 文件的任务\nconst videoHandler = function () {\n  return gulp.src('./src/videos/**').pipe(gulp.dest('./dist/videos/'))\n}\n\n// 1-7. 创建一个打包 audios 文件的任务\nconst audioHandler = function () {\n  return gulp.src('./src/audios/**').pipe(gulp.dest('./dist/audios/'))\n}\n\n// 1-8. 创建一个打包 第三方 的任务\nconst libHandler = function () {\n  return gulp.src('./src/lib/**/*').pipe(gulp.dest('./dist/lib/'))\n}\n\n// 1-9. 创建一个打包 fonts 文件的任务\nconst fontHandler = function () {\n  return gulp.src('./src/fonts/**/*').pipe(gulp.dest('./dist/fonts/'))\n}\n\n// 1-10. 创建一个删除 dist 目录的任务\nconst delHandler = function () {\n  // del 直接执行就可以了, 不需要流\n  // 参数以数组的形式传递你要删除的文件夹\n  return del(['./dist/'])\n}\n\n// 1-11. 创建一个启动 服务器 的任务\nconst webHandler = function () {\n  return gulp.src('./dist').pipe(\n    webserver({\n      host: 'localhost', // 域名(可以配置自定义域名)\n      port: '8080', // 端口号\n      livereload: true, // 当文件修改的时候, 是否自动刷新页面\n      open: './pages/login.html', // 默认打开哪一个文件(从 dist 目录以后的目录开始书写)\n      proxies: [\n        // 配置你的所有代理\n        // 每一个代理就是一个对象数据类型\n        // 注意: 如果你没有代理, 不要写空对象\n        {\n          // 代理标识符\n          source: '/dt',\n          // 代理目标地址\n          target: 'https://www.duitang.com/napi/blog/list/by_filter_id/',\n        },\n        {\n          source: '/gx',\n          target: 'http://localhost:80/server.php',\n        },\n        {\n          source: '/gx2',\n          target: 'http://localhost:80/',\n        },\n      ],\n    })\n  )\n}\n\n// 1-12. 创建一个监控任务\nconst watchHandler = function () {\n  // 使用 gulp.watch()\n  gulp.watch('./src/sass/*.scss', sassHandler)\n  gulp.watch('./src/css/*.css', cssHandler)\n  gulp.watch('./src/js/*.js', jsHandler)\n  gulp.watch('./src/pages/*.html', htmlHandler)\n}\n\n// 3. 配置一个默认任务\nmodule.exports.default = gulp.series(\n  delHandler, // 执行删除任务，删除原有的结果文件\n  gulp.parallel(\n    cssHandler,\n    sassHandler,\n    jsHandler,\n    htmlHandler,\n    imgHandler,\n    videoHandler,\n    audioHandler,\n    libHandler,\n    fontHandler\n  ), // 并行执行指定任务\n  webHandler, // 开启基于node的服务\n  watchHandler // 监控指定文件，文件一旦发生变化就会执行指定的任务\n)\n```\n","tags":["前端","gulp"],"categories":["前端"]},{"title":"css3渐变颜色","url":"/2021/07/09/CSS/css3渐变颜色/","content":"\n### CSS3 渐变色\n\n#### 1. 线性渐变\n\n```css\n.box1 {\n  /** 渐变属性是设置在background-image上的 */\n  /** 线性渐变 linear-gradient 默认从上到下渐变 */\n  background-image: linear-gradient(#e66465, #9198e5);\n}\n.box2 {\n  /** 线性渐变 linear-gradient 默认从左上往右下渐变 */\n  background-image: linear-gradient(to right bottom, #e66465, #9198e5);\n}\n.box3 {\n  /** 线性渐变 linear-gradient  */\n  background-image: linear-gradient(to left, #e66465, #9198e5);\n}\n.box4 {\n  /** 线性渐变 linear-gradient  */\n  background-image: linear-gradient(#e66465, #9198e5, green);\n}\n.box5 {\n  /** 线性渐变 linear-gradient */\n  background-image: repeating-linear-gradient(\n    #e66465 5%,\n    #9198e5 10%,\n    green 20%\n  );\n}\n```\n","tags":["前端","css"],"categories":["前端","css"]},{"title":"js常见手写代码","url":"/2021/05/25/JS/js手写代码/","content":"\n### 1. 使用函数柯里化实现累加\n\n```js\nconst es6Add = (...args) => {\n  let list = [].slice.call(args) // 将实参转化为数组\n  let fn = (...args2) => {\n    let list2 = [].slice.call(args2)\n    list.push(...list2) // 每次调用都进行数组合并\n    return fn // 通过递归 return fn 的方式让函数可以实现多次调用\n  }\n  fn.toString = () => {\n    // 重写函数的 toString 方法\n    return list.reduce((pre, next) => {\n      // 计算数组的累加\n      return pre + next\n    })\n  }\n  return fn\n}\nconsole.log(es6Add(1, 2, 3)(4)) // fn 10\n```\n\n### 2. 手写 js 的深拷贝\n\n```js\nconst deepClone = (target, map = new WeakMap()) => {\n  // 首先判断 target 是否被 map 记录过\n  if (map.get(target)) {\n    // 如果被 map 记录过就直接返回\n    return target\n  }\n  // 获取 target 的构造器\n  let constructor = target.constructor\n  // 判断 constructor 是否是 RegRxp 和 Date 类型\n  if (/^(RegExp|Date)$/i.test(constructor.name)) {\n    // 判断为 true 的话，实例化创建对应类型的对象然后返回\n    return new constructor(target)\n  }\n  // 判断 target 是 Object 或者 Function 并且 不为null\n  if (\n    (typeof target === 'object' || typeof target === 'function') &&\n    target !== null\n  ) {\n    // 将 target 放入map 标记为 true， 用于上面的判断\n    map.set(target, true)\n    // 判断 target 是否数组 设置数据类型 初始值\n    let resultTarget = Array.isArray(target) ? [] : {}\n    for (const key in target) {\n      // 过滤调原型上的属性 只对独有属性进行拷贝\n      if (target.hasOwnProperty(key)) {\n        resultTarget[key] = deepClone(target[key], map)\n      }\n    }\n    return resultTarget\n  } else {\n    // 到这里的都是 基本数据类型 直接返回\n    return target\n  }\n}\n// 基本数据类型验证\nlet a = 1\nlet b = deepClone(a)\nconsole.log('b', b) // b 1\nb = 2\nconsole.log('b', b) // b 2\nconsole.log('a', a) // a 1\n\n// 引用类型 验证\nlet obj = {\n  name: 'xiaozhao',\n  age: '24',\n  cars: ['小鹏', '雅阁', '凯迪拉克'],\n}\nlet cloneObj = deepClone(obj)\ncloneObj.cars[2] = '兰博基尼'\nconsole.log('cloneObj', cloneObj)\n// {age: \"24\"\n// cars: (3) [\"小鹏\", \"雅阁\", \"兰博基尼\"]\n// name: \"xiaozhao\"\n// __proto__: Object}\nconsole.log('obj', obj)\n// {age: \"24\"\n// cars: (3) [\"小鹏\", \"雅阁\", \"凯迪拉克\"]\n// name: \"xiaozhao\"\n// __proto__: Object}\n```\n","tags":["js","面试"],"categories":["前端","js"]},{"title":"W3C 标准和 Web语义化","url":"/2021/05/07/W3C标准和Web语义化/","content":"\n# W3C 标准和 Web 语义化\n\n## w3c 标准\n\nW3C 是万维网联盟（World Wide Web Consortium）\n\n### 一、使用 W3C 的目的\n\n​ 我们开发者作为中间件也就是 **转换器** adapter，我们需要想方设法让我们的页面、我们的程序能够支持所有的浏览器、能够满足尽可能多的用户。我们要满足所有的客户，即使做不到，我们也要满足我们技术范围之内的所有用户。\n\n### 二、标准内容\n\n#### 1. 什么是 DOCTYPE\n\n​ DOCTYPE 是 document type(文档类型)的简写，用来说明你用的 XHTML 或者 HTML 是什么版本。其中的 DTD(例如 xhtml1-transitional.dtd)叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的 DTD 来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE 声明是必不可少的关键组成部分；除非你的 XHTML 确定了一个正确的 DOCTYPE，否则你的标识和 CSS 都不会生效。\n\n​ XHTML 1.0 提供了三种 DTD 声明可供选择：\n\n- **过渡的**(Transitional)：要求非常宽松的 DTD，它允许你继续使用 HTML4.01 的标识(但是要符合 xhtml 的写法)。\n\n  ```html\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n  ```\n\n- **严格的**(Strict)：要求严格的 DTD，你不能使用任何表现层的标识和属性：\n\n  ```html\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n  ```\n\n- **框架的**(Frameset)：专门针对框架页面设计使用的 DTD，如果你的页面中包含有框架，需要采用这种 DTD:\n\n  ```html\n  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n  ```\n\n#### 2.名字空间（namespace）\n\n`<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"gb2312\">`\n\n通常我们 HTML4.0 的代码只是<html>，这里的\"xmlns\"是什么呢？\n\n​ 这个“xmlns”是 XHTML namespace 的缩写，叫做“名字空间”声明。XHTML 是 HTML 向 XML 过渡的标识语言，它需要符合 XML 文档规则，因此也需要定义名字空间。又因为 XHTML1.0 不能自定义标识，所以它的名字空间都相同，就是\"http://www.w3.org/1999/xhtml\"。目前阶段我们只要照抄代码就可以了。\n\n#### 3.定义语言编码\n\n`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\" />`\n\n​ 为了被浏览器正确解释和通过 W3C 代码校验，所有的 XHTML 文档都必须声明它们所使用的编码语言，我们一般使用 gb2312(简体中文)，制作多国语言页面也有可能用 Unicode、ISO-8859-1 等，根据你的需要定义。\n\n> 注：如果忘记了定义语言编码,可能就会出现,你在 DW(dreamweaver)做完一个页面，第二次打开时所有的中文变成了乱码。\n\n#### 4.Javascript 定义\n\n​ js 必须要用 `<script language=\"javascript\" type=\"text/javascript\">` 来开头定义：\n\n```html\n<script language=\"javascript\" type=\"text/javascript\">\n  //<![CDATA[\n  function show_layout(selObj) {\n    var n = selObj.options[selObj.selectedIndex].value\n    document.getElementById('stylesheet').href = n\n  }\n  //]]>\n</script>\n```\n\n#### 5.CSS 定义\n\n​ CSS 必须要用 `<style type=\"text/css\">` 开头来定义，而不是原来的直接`<style>`，也不建议直接写在内容代码里如：`<div style=\"padding-left:20px;\"></div>`，并需要加个注释符<!-- -->\n\n```css\n<style type=\"text/css\" media=\"screen\">\n<!--\nbody {margin:0px;padding:0px;font-size:12px;text-align:center}\n-->\n</style>\n```\n\n#### 6.不要再注释内容中使用‘--’\n\n​ ‘--’ 只能出现在 XHTML 注释的开头和结束，在内容中间不再有效\n\n例如：<!-- 注释------------注释 --> 是无效的，正确的应用是用=或空格代替内部的虚线；\n\n#### 7.标签的元素和属性名必须小写\n\n​ XHTML 大小写是敏感的，<title> 和 <TITLE> 是不同的标签。XHTML 要求所有的标签和属性的名字都必须使用小写，大小写夹杂也是不被认可的，通常 Dreamweaver 自动生成的属性名\"onMouseOver\"也必须修改为\"onmouseover\"；\n\n#### 8.所有的属性必须用\"\"括起来\n\n​ 在 HTML 中，可以不需要给属性值加引号，但在 XHTML 中，它们必须被加引号，例如<height=80>必须修改为<height=\"80\">\n\n> 如果必须在属性值里使用双引号，可以用\",单引号可以使用&apos;\n\n#### 9.把所有<和&特殊符号用编码表示\n\n​ 任何小于号(<),不是标签的一部分，都必须被编码为<kbd>`&lt;`</kbd>\n\n​ 任何大于号(>),不是标签的一部分，都必须被编码为<kbd>`&gt;`</kbd>\n\n​ 任何与号(&),不是实体的一部分，都必须被编码为<kbd>`&amp;`</kbd>\n\n#### 10.给所有属性赋值\n\n​ XHTML 规定所有的属性都必须有一个值，没有值的就重复本身;\n\n#### 11.所有的标记都必须有一个相应的结束标记\n\nXHTML 要求有严谨的结构，所有标签必须关闭，如果是单独不成对的标签，在标签最后加一个\"/\"来关闭它;\n\n#### 12.所有标记都必须合理嵌套\n\n​ 错误：`<p><b></p></b>`\n\n​ 正确：`<p><b></b></p>`\n\n#### 13.图片添加有意义的 alt\n\n​ 尽可能让作为内容的图片都带有属于自己的属性。\n\n​ 同理：添加文字链接的 title 属性\n\n#### 14.在 form 表单中增加 lable，以增加用户友好度\n\n## Web 语义化\n\n### web 语义化的目的\n\n- **代码结构:** 使页面没有 css 的情况下，也能够呈现出很好的内容结构；\n\n- **有利于 SEO:** 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息；\n- **提升用户体验：** 例如**title**、**alt**可以用于解释名称或者解释图片信息，以及**label**标签的灵活运用；\n- **便于团队开发和维护:** 语义化使得代码更具有可读性，让其他开发人员更加理解你的 html 结构，减少差异化；\n- **方便其他设备解析:** 如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页；\n\n### 什么是语义元素？\n\n语义是指对一个词或者句子含义的正确解释。很多 html 标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到`<h1></h1>`标签时，它将该标签解释为包含这一块内容的最重要的标题。h1 标签的语义就是用它来标识特定网页或部分最重要的标题。\n\n#### 常见的语义化标签\n\n|                               **结构体**                               |                  **文本**                  |                   **一致**                   |\n| :--------------------------------------------------------------------: | :----------------------------------------: | :------------------------------------------: |\n| header<br/>h1<br/>h2<br/>h3<br/>nav<br/>footer<br/>article<br/>section | p<br/>ul<br/>ol<br/>li<br/>block<br/>quote | a<br/>strong<br/>em<br/>q<br/>abbrs<br/>mall |\n","tags":["前端"],"categories":["前端"]},{"title":"前端工程化、模块儿化、组件化","url":"/2021/05/01/前端工程化/","content":"\n### 简单介绍一下对前端工程化、模块儿化、组件化的理解\n\n#### 前端工程化\n\n- 前端工程化是一种思想：我们拿到一个项目之后，把它当成一项系统的工程来对待，对它进行分工、组织和构建、从而达到分工明确、开发人员配合默契以及高效开发的目的；\n\n- 工程化的思维就是将“结构、样式和动作” 分离：例如将静态资源放在assets和static中，将工具类的js放在utils中，将组件放在components中；\n\n#### 前端模块化\n\n- 前端模块儿化：可以理解为将一组功能单独提取出来，在需要使用的时候通过require()或者import引入使用，可以达到按需加载；\n\n- CSS实现模块儿化通过：scss、less、stylus;\n\n- CommonJs：将一个js文件单独提取出来，通过module.exports将内容作为模块儿导出；\n\n- Module：是es6的模块化，将js文件中的内容通过export.default作为模块儿导出，需要时通过` import XXX from 'XXX'; `导入使用;\n\n- 另外还有AMD、CMD、UMD都实现了前端模块儿化；\n\n#### 组件化开发\n\n- 我们熟悉的Vue、React框架都采用了组件化开发，我们清晰的体验到组件化开发的高效、便利以及代码的清晰度；\n\n- 组件化相当于将一个页面视作一个容器，组件就相当于其中的头部、脚部、列表等很多东西、这些东西作为组件在需要时添加进去，组件是可以复用的，而且相互之间不会产生影响；","tags":["面试"],"categories":["前端"]},{"title":"webpack知识","url":"/2021/04/28/打包工具/webpack知识/","content":"\n### 说一下 webpack 的配置分离和配置合并是如何实现的\n\n- 安装`webpack-merge`，用于将文件合并\n\n- 创建三个文件，一个用来放 webpack 的公共配置，一个放开发环境打包配置，一个放生产环境打包配置\n\n- 通过`const webpackMerge = require('webpack-merge')`的 webpackMerge()函数来合并各自环境配置和公共配置\n\n- 在 package.json 配置文件中，配置相应的命令以及各自文件的路径\n\n### webpack-dev-server 的作用和用法\n\n- 作用：\n\n  - 是 webpack 官方提供的一个小型 express 服务器，可以为 webpack 打包生成的静态资源文件提供 web 服务\n  - 自动刷新和热替换\n  - 通过配置 proxy 可以解决开发过程中的跨域问题\n\n- 使用：\n\n  - 安装`npm install webpack-dev-server --save-dev`\n  - 在 package.json 中配置 webpack-dev-server 的打包命令，执行命令会将包打在内存中\n  - webpack 配置文件中使用以下配置：\n\n  ```js\n  devServer: {\n    host: '0.0.0.0',\n    port: port,\n    open: true,\n    /** 配置代理请求，可以解决跨域问题 */\n    proxy: {\n      '/api': {\n        target: `http://192.168.0.113:58037`,\n        changeOrigin: true,\n        pathRewrite: {\n          '^/api': ''\n        }\n      }\n    },\n    disableHostCheck: true\n  },\n  ```\n\n### webpack-dev-server 和 http 服务器比如 nginx 的区别\n\n- webpack-dev-server 是使用内存来存储 webpack 在开发环境下的打包文件，并且可以使用热更新模块儿，比传统的 http 服务器开发更加简单高效\n\n### webpack 处理样式文件\n\n- 假设我们的项目中有 sass 文件，有 css 文件，有样式文件的引入关系，同时要解决浏览器兼容问题\n\n- 在 webpack 配置文件中的 module 模块儿中的 rules 添加处理文件的配置，需要用到以下 4 个 loader\n\n  - style-loader：作用是将 css 样式内容放在打包后的 html 页面上；\n  - css-loader：作用是用来处理 css 文件之间的引用关系；\n  - postcss-loader：作用是处理指定浏览器以及版本的兼容性问题，需要创建 postcss 配置文件，在里面引用插件`autoprefixer`，最后在 package.json 文件中配置所需要兼容的浏览器类型和版本`browsersList`;\n  - sass-loader：作用时将 sass 解析成 css\n  - 另外 loader 的执行顺序是按照配置的倒叙进行的\n\n### webpack 处理图片\n\n- 使用 url-loader,建议通过配置项将小图片打包成 base64 字符串，需要配置 options 的 limit，否则默认将所有图片转化问 base64\n","tags":["面试","webpack"],"categories":["前端"]},{"title":"vuex知识","url":"/2021/04/26/Vue/vuex知识/","content":"\n### 1. vuex 的几个核心属性\n\n- vuex 是一个全局的状态管理器；\n\n- state：state 是数据源存放地，对应 vue 组件中的 data，其中的数据都是响应式的；vue 组件可以从 store 中读取数据，当 store 中的数据发生改变的时候，那么依赖它的视图也会更新；\n\n- mutations：其中定义的方法是用来动态修改 state 中的状态数据的，通过 commit 提交来调用，方法必须是同步的；\n\n- actions：就是将 mutations 中处理数据的方式变成异步的，异步拿数据，通过 commit 调用 mutations 中的方法更新数据，actions 通过 store.dispatch 分发\n\n- modules：模块儿化 vuex\n\n- getters：主要用来过滤数据，对应 vue 组件中的计算属性(computed)，可以在多组件之间复用\n\n### 2. 为什么 mutations 中的方法必须是同步的(在严格模式下)\n\n- Vuex 中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n- 每个 mutation 执行完成后都会对应到一个新的状态变更，这样 devtools 就可以打个快照存下来，然后就可以实现 time-travel 了。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\n### 3. 如何在 vue 组件中使用 vuex 的内容\n\n- 直接获取、修改\n\n  ```js\n  //state\n  this.$store.state.count\n  //getter\n  this.$store.getters.count\n  //调用 action 修改 state 值，不带参数\n  this.$store.dispatch('increment')\n  //调用 action 修改 state 值，带参数\n  this.$store.dispatch('increment', { value: 123 })\n  ```\n\n- 通过辅助函数获取、修改\n\n  ```js\n  /** vuex提供了三种辅助函数用于获取、修改vuex：\n    mapState、mapGetters、mapActions\n    将vuex的变量或者方法映射到vue组件this指针上。\n    */\n  //使用state获取共享变量\n  <script type=\"text/javascript\">\n  import { mapState } from 'vuex'\n  export default{\n    computed : {\n      ...mapState([\n          'count',\n          'buttonShow'\n      ])\n    }\n  }\n  </script>\n  //使用mapGetters获取共享变量，\n  <script type=\"text/javascript\">\n  import { mapGetters } from 'vuex'\n  export default{\n    computed : {\n      ...mapGetters([\n          'count',\n          'buttonShow'\n      ])\n    }\n  }\n  </script>\n  //使用actions修改共享变量\n  <script type=\"text/javascript\">\n  import { mapActions } from 'vuex'\n  export default{\n    methods : {\n      ...mapActions({increment:'increment',decrement:'decrement'}),\n    }\n  }\n  </script>\n  ```\n","tags":["前端","vuex"],"categories":["前端","vue"]},{"title":"vue-router知识","url":"/2021/04/22/Vue/vue-router知识/","content":"\n### 1. vue-router 的跳转和 location.href 跳转的区别？\n\n- location.href 跳转虽然简单方便，但是每次跳转的是页面，需要刷新页面；\n\n- vue-router 跳转是采用了 diff 算法实现了按需加载，减少了 dom 的消耗\n\n### 2. vue-router 的跳转方式\n\n- vue-router 实现单页面路由跳转，提供了三种方式：hash、history、abstract，根据参数 mode 来设置使用哪种方式；\n\n- hash 和 history 的区别：\n\n  - hash 模式在地址栏中会有一个'#'号，history 模式没有；\n  - 虽然 hash 出现在地址栏中，但是它不会影响 HTTP 请求，因此不会对后端产生影响，也不会导致页面的重新加载；\n  - history 模式是利用了 HTML5 提供的 pushState()和 pushReplace(),这两个方式应用于浏览器的历史记录栈，在原有的 go、back、forward 的基础上，它们提供了对历史记录进行修改的功能，知识当他们修改的时候，虽然改变了当前 url，但是浏览器不会立即向后端发送请求\n  - hash 可以支持低版本的 IE 浏览器，history 需要特定浏览器支持；\n  - history 一般需要后端将所有页面配置重定向到首页路由；\n\n### 3. 路由之间的跳转方式\n\n- 声明式（标签式）：router-link 标签配合它的 to 属性\n\n- 编程式：在 js 中进行路由跳转 `this.$router.push('/')`\n\n### 4. 路由传参中 params 和 query 的区别\n\n- 用法上的：query 需要用 path 来引入，params 需要用 name 引入，接收参数基本一样：`this.$route.query || this.$route.params`，注意接收的时候使用的是 **$route**\n\n- 展示上来看：query 相当于我们 ajax 中的 get 请求，参数会显示在地址栏中；params 相当于 post 请求，参数不显示在地址栏中\n\n- 注意：query 刷新不会丢失参数、params 刷新会丢失参数\n\n### 5. $router 和 $route 的区别\n\n- $router：是‘路由实例’，包含了路由的跳转方法以及钩子函数等；\n\n- $route：是‘路由信息对象’，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。\n\n### 6. vue 的动态路由如何定义，以及怎么获取动态参数\n\n- 什么是动态路由：举个例子，比如商品详情页，页面结构都是一致的，只有 id 不一样，这个时候就要用到动态路由\n\n- 创建动态路由：在 routes 中在使用 path 的时候使用动态路径参数，以冒号开头\n\n- 获取动态路由的参数：`this.$route.params`\n\n### 7. vue-router 的导航守卫有哪些\n\n- 全局前置守卫：`router.beforeEach((to,from,next) => {})`\n\n  - to：指的是要进入的 route 对象\n  - from：指的是导航正要离开的 route 对象\n  - next：Function() 该方法一定要被调用，它可以让导航进入下一个钩子、可以中断导航`next(false)`、可以中断当前导航进入指定的其它导航`next({path: '/'})`\n\n- 全局解析守卫：`router.beforeResolve` 用法和全局前置守卫基本一致，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件解析之后被调用\n\n- 全局后置钩子：`router.afterEach((to,from) => {})` 只有两个参数，不接受 next 函数也不影响导航本身\n\n- 路由独享守卫：`beforeEnter((to,from,next) => {})` 在路由配置的时候直接加上的守卫，参数和方法与全局前置守卫一致\n\n- 组件内的守卫：\n\n  - beforeRouteEnter()：在渲染该组件的对应路由确认前被调用、不能获取 this 实例因为当守卫被执行前组件实例还没被创建，可以通过`next(vm => {})`传参‘vm’来使用实例\n  - beforeRouteUpdate()：当前路由发生改变，同时组件被复用的时候执行，举个例子（动态路由之间的跳转会触发这个守卫）、可以访问 **this**\n  - beforeRouteLeave()：当行离开该组件路由的时候被调用、可以使用 **this**，通常用来检查用户操作未保存时突然离开、通过`next(false)`取消导航\n\n### 8. 完整的导航解析流程\n\n- 导航被触发\n\n- 调用失活的组件中的`beforeRouteLeave`\n\n- 调用 router 实例的全局前置守卫`beforeEach`\n\n- 如果组件被复用的话调用组件内守卫`beforeRouteUpdate`\n\n- 调用路由配置中的独享守卫`beforeEnter`\n\n- 解析异步路由组件\n\n- 在被激活的组件中调用`beforeRouteEnter`\n\n- 调用全局解析守卫`beforeResolve`\n\n- 导航被确认\n\n- 调用全局后置钩子`afterEach`\n\n- 触发 DOM 更新\n\n- 调用`beforeRouteEnter`中的 next 中的回调函数，创建好的实例会作为回调函数的参数传入\n\n### 重点\n\n- 当参数或查询条件的改变是不会触发引入或离开的导航守卫，一般通过 watch 来观察$route 的变化或者使用 beforeRouteUpdate 组件内守卫\n\n### 9. vue-router 实现路由懒加载\n\n- 路由懒加载就是采用异步组件和 webpack 的代码分割功能实现的\n\n- 如果不使用路由懒加载的话，打包构建后的应用的 javaScript 包会特别大，影响页面加载，所以我们要把不同的路由对应的组件分割成不同的代码块儿，当路由被访问的时候才去加载对应的组件；\n\n- 对于 SPA 来说，路由懒加载可以有效地降低首页的加载压力，优化项目性能；\n\n- 常见用法：\n\n  ```js\n  /** 第一种，也是最常用的 */\n  // 注释的意思是将chunkname相同的所有组件打包在同一个异步模块儿中\n  const Index = () =>\n    import(/* webpackChunkName: \"group-home\" */ '@/views/index')\n  const routers = [\n    {\n      path: '/',\n      name: 'index',\n      component: Index,\n    },\n  ]\n  /** 第二种 */\n  const Index = (r) =>\n    require.ensure([], () => r(require('./views/index')), 'group-home')\n  const routers = [\n    {\n      path: '/',\n      name: 'index',\n      component: Index,\n    },\n  ]\n  ```\n","tags":["前端","vue-router"],"categories":["前端","vue"]},{"title":"vuejs知识了解","url":"/2021/04/16/Vue/vuejs知识/","content":"\n### 1. 谈谈对 Vue.js 的理解\n\n- Vue 是一套用于构建用户界面的 **渐进式框架**，它的目标是通过 API 实现响应数据绑定和试图更新；\n\n- 官方对 Vue 的评价是易用性、高效性、灵活性，从这三点来看：\n\n  - 易用性：Vue 提供了响应式数据，可以在数据改变的时候更新视图，这就令开发者只需要关心核心代码逻辑；\n\n  - 灵活性：我们的应用足够小的时候，我们只需要使用 vue 的核心库就可以了；当业务逐渐复杂的时候，可以引入 vue-router、vuex 等其他工具；\n\n  - 高效性：vue 操作的是虚拟 DOM，采用 diff 算法来更新 DOM，相比传统的 dom 操作更加高效；\n\n- 缺点：不支持 IE8 及以下版本；\n\n### 2. 什么是 SPA？\n\n- SPA 就是单页面应用，也就是只有一个 web 页面的应用\n\n- 相对于传统的多页面应用来说：减少了应用体积、加快了页面的响应速度、降低了服务器的压力以及更好的用户体验\n\n- 缺点：因为使用了 ajax，导致页面不利于 SEO（SEO 原则：搜索引擎的蜘蛛只识别 href 的一般超链接，而不识别 JavaScript 代码，遇到一般超链接就会爬进去，遇到 JavaScript 不会爬进去。即，搜索引擎抓不到 AJAX 动态加载的内容），但是可以通过其他技术去规避；\n\n  - 服务端渲染、页面静态化\n\n### 3. Vue 的生命周期\n\n#### 什么是 vue 的生命周期\n\n- 生命周期就是 vue 实例从创建到销毁的过程\n\n#### vue 的生命周期总共有几个阶段\n\n- 创建前、创建后、载入前、载入后、更新前、更新后、销毁前、销毁后\n\n#### 生命周期中钩子函数的作用\n\n- 生命周期中有多个事件函数，它们的存在是为了让我们形成更好的开发逻辑\n\n#### 第一次页面加载会触发哪几个钩子函数\n\n- beforeCreate、created、beforeMount、mounted\n\n#### 生命周期钩子的一些使用方法\n\n- beforeCreate：一般加入 loading 事件\n\n- created：结束 loading 事件，获取异步请求数据\n\n- mounted：dom 挂载完成，可以获取 dom 节点信息\n\n- updated：如果对数据进行了统一处理，这里写上响应函数\n\n- beforeDestroy：通常关闭组件中占用内存的东西，比如 setTimeout\n\n- nextTick：如果再修改数据之后操作 dom 的话需要在此函数内\n\n### 4. MVVM\n\n- MVVM 就是 Model-View-ViewModel 的缩写\n\n- Model：数据模型，通常指的是后端传过来的数据；\n\n- View：代表 UI 组件，它负责将数据模型转换成 UI 展现出来；\n\n- ViewModel：是 MVVM 的核心。是连接 View 和 Model 的桥梁，用来同步 View 和 Model 的对象；\n\n- 优点：\n\n  - 分离视图 View 和数据模型 Model，降低代码耦合、以及提高了视图或逻辑的复用性；\n  - 自动更新 DOM，避免了 DOM 的重复操作\n\n### 5. 为什么组件中的 data 必须是一个函数\n\n- 因为 vue 组件是一个封装自己单独功能的模块儿，有自己的 html 模板，也应该有自己的 data\n\n- vue 组件不能直接访问 vue 实例上的数据，就算可以访问，那所有的参数放在 vue 实例上会显得臃肿。而且多个组件使用同一组数据的话，他们对数据的操作会影响到其他组件\n\n- 因此 vue 组件需要自己的 data，而且必须是一个函数返回一个对象\n\n### 6. vue 的两个核心点\n\n- 数据驱动：ViewModel，它的主要作用就是保证视图与数据一致性（也就是 vue 实现响应式的原理）\n\n- 组件系统：组件化、页面上可以使用多个组件而且可以实现组件复用、令 vue 开发更加灵活\n\n### 7. vue 父子组件的通讯\n\n- 父组件通过属性传递数据到子组件，子组件通过 props 接收参数；\n\n- 子组件通过$emit 向父组件传递参数，父组件通过事件接收参数；\n\n- 兄弟组件不能通过这种方式，因为他们之间没有任何可以相互依赖的关系；实现通讯的话就需要借助第三方：\n  - eventBus：建立一个事件中心来传递事件，进行数据传递\n  - Vuex：全局状态管理，所有组件都可以调用状态（数据）\n\n### 8. 函数式组件的优势\n\n- 渲染开销特别小、因为它只是一个函数，没有状态没有实例\n\n### 9. vue 的事件修饰符\n\n- .stop：用来阻止事件冒泡；\n\n- .prevent：阻止组件本来应该发生的事件，常用于 a 标签事件；\n\n- .capture：将冒泡事件顺序改变，必须放在最外层进行修饰；\n\n- .once：用来修饰事件响应较慢但不能多次触发，只能触发一次的事件；\n\n- .self：只有点击当前自身元素才触发的修饰符；\n\n### 10. vue 自定义指令的原理\n\n- 本质上相当于装饰器，是 vue 对 html 的扩展，语义化 html，也就是在 vue 编译 dom 时，找到指令所修饰的对象，执行指令中的 js 代码\n\n- 生命周期钩子：bind、inserted、update、componentUpdated、unbind\n\n### 11. vue 为什么要采用异步更新\n\n- 异步更新是指：本轮数据更新结束之后，再去更新视图；\n\n- vue 的更新是组件级更新，每次更新都会渲染整个组件，如果使用同步更新的话，只要 data 的数据发生变化就会触发 watcher，然后对应 watcher 下的 update 方法更新视图，这样就会导致组件更新特别频繁，资源浪费；\n\n- vue 异步更新流程\n\n  - 当 data 数据发生变化时，会触发 dep.notify() 通知 watcher 执行 update();\n\n  - 调用 queueWatcher 将 watcher 去重后加入队列等待执行；\n\n  - 在 nextTick 的回调 flushSchedulerQueue 内将刚刚加入的 watcher 逐个执行 run 进行更新；\n\n  - 最后执行 restSchedulerState()重置状态等待下一轮更新\n\n### 12. vue3 的 proxy()与 vue2 的 Object.defineProperty()的对比\n\n- proxy\n\n  - proxy 可以直接监听对象，而不仅仅是属性；\n  - proxy 也可以直接监听数组的变化；\n  - proxy 可以返回一个新对象，可以操作新对象来达到目的，而 Object.defineProperty 只能遍历属性进行修改；\n  - proxy 作为新标准，将会受到各个浏览器厂商的持续优化\n\n- Object.defineProperty\n  - Object.defineProperty()兼容 IE9 版本\n\n### 13. 子组件为什么不能修改父组件传递的 prop\n\n- Vue 中提倡的是单向数据流，父组件修改了 props 的时候是会流向子组件的，反过来就不行，为了防止子组件意外的更新了父组件的状态，如果破坏了单向数据流，那么当应用复杂的时候，debug 的成本会非常高\n\n### 14. 使用 v-for 的时候为什么要用 key\n\n- key 的唯一性，它的存在可以让 diff 算法更快的找到需要更新的 dom 节点，注意：key 一定要唯一，否则可能会出现一些特别隐蔽的更新异常；\n\n### 15. 为什么不建议 v-for 和 v-if 同时使用\n\n- 因为 v-for 的优先级高于 v-if，表示每一次遍历都会通过 v-if 进行判断，如果需要遍历的数组长度特别大，就会造成很严重的性能浪费；\n\n- 因此遇到这种情况的话我一般会先用 computed 进行数据的筛选之后遍历\n\n### 16. keep-alive 的作用以及什么时候使用\n\n- keep-alive：是 vue 内置的一个组件，它可以使被包含的组件保留状态，当组件切换的时候避免重新渲染；\n\n- props:\n\n  - include：字符串或正则表达式。只有匹配的组件会被缓存。\n  - exclude：字符串或正则表达式。任何匹配的组件都不会被缓存。\n\n- 当组件在 keep-alive 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。**主要用于保留组件状态或避免重新渲染**。\n\n- keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例。\n\n### 17. vue 的模板编译\n\n- 模板编译的作用：是生成渲染函数-->执行渲染函数生成最新的 vnode-->根据 vnode 来渲染 dom\n\n- 渲染函数的生成过程：首先将模板编译成 AST(抽象语法树)，然后遍历 AST 将其中的静态节点进行标记，最后根据 AST 生成渲染函数\n\n### 18. scoped 的实现及原理\n\n- 为了避免 css 样式的污染，vue 组件中给 css 提供了 scoped 来实现样式私有化、模块化\n\n- 包含 scoped 的组件的所有节点都会有一个唯一的标识（[data-v-xxxxx]）\n\n- 包含 scoped 组件中的所有样式选择器后面会加上节点上的那个唯一标识\n\n### 19. SPA 首次进入页面出现白屏的原因以及解决方法\n\n- 因为 SPA 运行时浏览器会在进入应用的时候下载所有需要的资源，当资源过多时就会出现白屏的情况；\n\n- 解决方法：采用图片懒加载、路由懒加载以及组件按需引入的方式\n\n### 20. vue 项目的行能优化\n\n- 不要在模板中写过多表达式\n\n- 在循环调用子组件时要用 key\n\n- 页面上频繁切换的情况用 v-show、很少切换的用 v-if\n\n- 尽量少用 float、可以使用 flex\n\n- 使用组件的按需加载 require 和 import 的方式\n\n- 路由懒加载和图片懒加载\n\n### 21. slot 插槽的作用\n\n- 简单来说，假如父组件需要在子组件内放一些 DOM，那么这些 DOM 是显示、不显示、在哪个地方显示、如何显示，就是 slot 分发负责的活\n\n### 22. slot 的种类\n\n- 匿名插槽：最简单常用的插槽子组件中只需要`<slot></slot>`就行了，父组件在组件内部放入内容；\n\n- 具名插槽：子组件在`<slot name=\"header\"></slot>`中加入 name 属性，父组件`<template v-slot:header></template>`\n\n- 作用域插槽：当父组件想要控制子组件显示子组件 data 中的数据时，需要用的作用于插槽，将子组件的数据传入父组件\n\n```js\n// 子组件\n<slot v-bind:user=\"userInfo\"></slot>\n// 父组件\n<template v-slot=\"user\"></template>\n```\n\n### 23. 简单说一下封装组件的过程\n\n- 先把组件的架子搭起来：html + js + css，然后思考逻辑\n\n- 准备好组件的数据输入，也就是定好 props 的数据以及类型\n\n- 准备好数据输出，就是向父组件传递的结果\n\n- 引入注册使用\n\n### 24. vue 组件的渲染和更新\n\n- 初次渲染\n\n  - 将模板解析为 render 函数；\n  - 触发响应式，将 data 中的数据通过 Object.defineProperty 的 getter 进行依赖收集；\n  - 执行 render 函数，生成 vnode，渲染视图（patch）\n\n- 组件更新\n  - 修改 data 中的数据，触发 setter 中的 dep.notify(),通知所有的 watcher 对象进行视图更新；\n  - 重新执行 render 函数，生成新的虚拟节点；\n  - 最后进行 patch 过程（diff 算法）\n\n### 25. 为什么使用异步组件\n\n- 异步组件可以优化打包结果，将异步组件分开打包，实现异步加载，可以有效地解决组件过大的问题，如果不使用异步组件，打包出来之后会出现首屏加载过慢甚至白屏的出现；\n\n- 按需加载组件，组件定义的时候什么都不做，当组件第一次使用的时候再进行渲染，渲染之后会缓存下来方便之后的使用；\n\n- 提升用户体验，优化项目性能\n\n### 26. diff 算法的作用\n\n- vue 中数据的双向绑定实现了修改数据的时候，自动更新视图的功能，而且是只更新需要更新的地方；也就是数据发生变化的时候，会根据新数据生成新的 vdom，通过对比新旧 vdom 来更新 dom，dom-diff 做的就是这些事\n\n### 27. DOM-diff 做了哪些事儿\n\n- DOM-diff 也叫 patch，打补丁的意思，核心思想就是将旧的 VNode 通过修补得到新的 VNode，然后更新 dom，总而言之，它干了三件事儿：新增节点、删除节点、更新节点；\n\n  - 创建节点：VNode 类中有六种节点，但实际上能够被创建的节点只有三种：元素节点、注释节点、文本节点\n\n    - 首先判断该节点是不是元素节点，只需要判断 vnode 中是否含有 tag 标签，如果包含那么一定是元素节点，调用 createElement 方法创建节点，然后创建子结点最后插入到 dom 中\n    - 判断是不是注释节点，在 VNode 类中对注释节点有一个特殊的标记 isComment，我们只需要判断 isComment 是否为 true，如果是就调用 createComment 方法来创建注释节点，最后插入 dom 中\n    - 判断是不是文本节点，如果前两种都不符合的话就调用 createTextNode 方法创建文本节点，最后插入 dom\n\n  - 删除节点：如果新的 VDOM 上没有的节点，而旧的 VDOM 上有的话，我们就需要把这些节点从旧的 VDOM 上删除，我们只需要调用被删除节点的父节点的 removeChild 方法\n\n  - 更新节点：更新之前我们需要将新旧 dom 进行对比，当遇到静态节点时候直接返回，因为静态节点是不会因为数据的改变而发生变化的\n\n    - 如果新旧 VNode 是文本节点的话，就调用 setTextNode 方法来修改文本内容\n    - 如果 VNode 是元素节点的话，分两种情况：\n      - 该节点包含子节点\n        - 如果新节点包含子节点的话，就看旧节点是否包含子节点，如果旧节点包含子节点，那就通过递归来对比子节点并更新；如果就节点不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。\n      - 该节点不包含子节点\n        - 如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。\n\n### 28. vue 中为什么要使用虚拟（Virtual）DOM\n\n- 创建真实 DOM 的成本高：真实 dom 的节点的属性有很多，而虚拟 dom 的节点只需要实现几个必要的属性就可以了，成本低很多\n\n- 如果不使用 VDOM，频繁操作 dom 的时候会多次进行页面的回流和重绘，使用 VDOM 的话，让一次数据变动产生的所有 node 变化，通过 diff 算法对 vnode 进行修改，最后只需要对 DOM tree 进行一次修改，减少回流和重绘，提高性能；\n\n- VDOM 本质上是一个 js 对象，因此天生就具有跨平台的能力，可以实现在不同平台的准确使用\n","tags":["前端","vue","面试"],"categories":["前端","vue"]},{"title":"vue3.x的响应式原理","url":"/2021/03/28/Vue/vue3-reactive/","content":"\n### Vue3的响应式是通过ES6的 Proxy 实现的","tags":["前端","vue3"],"categories":["前端","vue"]},{"title":"vue2.x的响应式原理","url":"/2021/03/27/Vue/vue-reactive/","content":"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**可能很多接触过Vue的同行都会知道：vue实现数据的响应式是借助了<kbd>Object.defineProperty</kbd>方法，而这个方法的作用是监测Object的读取和修改。**\n\n### 实现对Object的变化监测\n\n- 也就是让我们能够知道数据在什么时候被读取，什么时候被赋值；\n\n ```js\n    let car = {}\n    let val = 3000\n    // 通过 defineProperty 方法给car添加了 price 属性 \n    // 并且对 price 属性的读和写通过 getter 和 setter 进行了拦截\n    Object.defineProperty(car, 'price', {\n        enumerable: true,\n        configurable: true,\n        get(){\n            console.log('price属性被读取了')\n            return val\n        },\n        set(newVal){\n            console.log('price属性被修改了')\n            val = newVal\n        }\n    })\n ```\n\n ![实现对象属性的‘可观测’](01.png)\n\n- 从图片中我们可以看到，当我们读写car的price属性时，它已经可以将读写信息反馈出来了；\n\n- 接下来了解一下**vue2**中是如何监测obj所有属性的读写情况的；\n\n ```js\n    // 源码位置：src/core/observer/index.js\n    /**\n     * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象\n     */\n    export class Observer {\n        constructor (value) {\n            this.value = value\n            // 给value新增一个__ob__属性，值为该value的Observer实例\n            // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作\n            def(value,'__ob__',this)\n            if (Array.isArray(value)) {\n                // 当value为数组时的逻辑\n                // ...\n            } else {\n                // 过滤掉数组之后只剩下对象\n                this.walk(value)\n            }\n        }\n        walk (obj: Object) {\n            // 获取obj的所有属性\n            const keys = Object.keys(obj)\n            for (let i = 0; i < keys.length; i++) {\n                defineReactive(obj, keys[i])\n            }\n        }\n    }\n    /**\n     * 使一个对象转化成可观测对象\n     * @param { Object } obj 对象\n     * @param { String } key 对象的key\n     * @param { Any } val 对象的某个key的值\n     */\n    function defineReactive (obj,key,val) {\n        // 如果只传了obj和key，那么val = obj[key]\n        if (arguments.length === 2) {\n            val = obj[key]\n        }\n        // 如果该属性是个 object 类型的对象，就使用递归重新创建Observer对象\n        if(typeof val === 'object'){\n            new Observer(val)\n        }\n        Object.defineProperty(obj, key, {\n            enumerable: true,\n            configurable: true,\n            get(){\n                console.log(`${key}属性被读取了`);\n                return val;\n            },\n            set(newVal){\n                if(val === newVal){\n                    return\n                }\n                console.log(`${key}属性被修改了`);\n                val = newVal;\n            }\n        })\n    }\n ```\n\n- 因此，当我们这样定义对象的话，就可以监测出对象所有属性的读写情况；\n\n ```js\n let car = new Observer({\n   'brand':'BMW',\n   'price':3000\n })\n ```\n\n#### 什么是依赖收集\n\n- 前面我们实现了让object数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。因此我们需要做到视图中谁用到了这个数据就更新谁；\n\n- 我们把\"谁用到了这个数据\"称为\"谁依赖了这个数据\",我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个数据的依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：\"你们依赖的数据变啦，你们该更新啦！\"。这个过程就是依赖收集；\n\n#### 何时依赖收集，何时通知依赖更新\n\n- 总结一句话就是：**在getter中收集依赖，在setter中通知依赖更新。**\n\n#### 把依赖收集在哪里\n\n- 我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个 **依赖管理器**，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器 **Dep** 类应运而生，代码如下：\n\n ```js\n    // 源码位置：src/core/observer/dep.js\n    export default class Dep {\n        constructor () {\n            this.subs = []\n        }\n        addSub (sub) {\n            this.subs.push(sub)\n        }\n        // 删除一个依赖\n        removeSub (sub) {\n            remove(this.subs, sub)\n        }\n        // 添加一个依赖\n        depend () {\n            if (window.target) {\n                this.addSub(window.target)\n            }\n        }\n        // 通知所有依赖更新\n        notify () {\n            const subs = this.subs.slice()\n            for (let i = 0, l = subs.length; i < l; i++) {\n                subs[i].update()\n            }\n        }\n    }\n    /**\n     * 从数组中删除一个元素\n     */\n    export function remove (arr, item) {\n        if (arr.length) {\n            const index = arr.indexOf(item)\n            if (index > -1) {\n                return arr.splice(index, 1)\n            }\n        }\n    }\n ```\n\n- 在上面的依赖管理器 **Dep** 类中，我们先初始化了一个 **subs** 数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。\n\n- 有了依赖管理器 **Dep** 之后，我们就可以在getter中添加依赖，在setter中通知依赖更新；\n\n ```js\n function defineReactive (obj,key,val) {\n    // 如果只传了obj和key，那么val = obj[key]\n    if (arguments.length === 2) {\n        val = obj[key]\n    }\n    // 如果该属性是个 object 类型的对象，就使用递归重新创建Observer对象\n    if(typeof val === 'object'){\n        new Observer(val)\n    }\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get(){\n            dep.depend()    // 在getter中收集依赖\n            return val;\n        },\n        set(newVal){\n            if(val === newVal){\n                return\n            }\n            val = newVal;\n            dep.notify()   // 在setter中通知依赖更新\n        }\n    })\n }\n ```\n\n- 在上述代码中，我们在getter中调用了**dep.depend()**方法收集依赖，在setter中调用**dep.notify()**方法通知所有依赖更新。\n\n#### 依赖到底指的是谁\n\n- 其实在Vue中还实现了一个叫做 **Watcher** 的类，而Watcher类的实例就是我们上面所说的那个\"谁\"。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个Watcher实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的Watch实例，由Watcher实例去通知真正的视图。\n\n ```js\nexport default class Watcher {\n    constructor (vm,expOrFn,cb) {\n        this.vm = vm;\n        this.cb = cb;\n        this.getter = parsePath(expOrFn)\n        this.value = this.get()\n    }\n    get () {\n        window.target = this;\n        const vm = this.vm\n        let value = this.getter.call(vm, vm)\n        window.target = undefined;\n        return value\n    }\n    update () {\n        const oldValue = this.value\n        this.value = this.get()\n        this.cb.call(this.vm, this.value, oldValue)\n    }\n}\n/**\n * Parse simple path.\n * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来\n * 例如：\n * data = {a:{b:{c:2}}}\n * parsePath('a.b.c')(data)  // 2\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path) {\n    if (bailRE.test(path)) {\n        return\n    }\n    const segments = path.split('.')\n    return function (obj) {\n        for (let i = 0; i < segments.length; i++) {\n            if (!obj) return\n            obj = obj[segments[i]]\n            }\n        return obj\n    }\n}\n ```\n\n- 谁用到了数据，谁就是依赖，我们就为谁创建一个Watcher实例，在创建Watcher实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个Watcher实例就代表这个依赖，当数据变化时，我们就通知Watcher实例，由Watcher实例再去通知真正的依赖。\n\n**那么，在创建Watcher实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？**\n\n- 当实例化Watcher类时，会先执行其构造函数;\n\n- 在构造函数中调用了this.get()实例方法;\n\n- 在get()方法中，首先通过window.target = this把实例自身赋给了全局的一个唯一对象window.target上，然后通过let value = this.getter.call(vm, vm)获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的getter，上文我们说过，在getter里会调用dep.depend()收集依赖，而在dep.depend()中取到挂载window.target上的值并将其存入依赖数组中，在get()方法最后将window.target释放掉;\n\n- 而当数据变化时，会触发数据的setter，在setter中调用了dep.notify()方法，在dep.notify()方法中，遍历所有依赖(即watcher实例)，执行依赖的update()方法，也就是Watcher类中的update()实例方法，在update()方法中调用数据变化的更新回调函数，从而更新视图;\n\n#### 总结\n\n**大致流程**\n\n- Data通过observer转换成了getter/setter的形式来追踪变化；\n\n- 当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中；\n\n- 当数据发生了变化时，会触发setter，从而向Dep中的依赖（即Watcher）发送通知；\n\n- Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等；\n\n### 实现对Array类型的变化监测\n\n#### Array类型的数据在哪里收集依赖\n\n- Array类型同样是在 **getter** 中收集依赖；\n\n#### 使Array型数据可观测\n\n##### 思路分析\n\n- Object的变化时通过setter来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的setter。但是Array型数据没有setter，怎么办？\n\n- 试想一下，要想让Array型数据发生变化，那必然是操作了Array，而JS中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：\n\n ```js\n    let arr = [1,2,3]\n    arr.push(4)\n    Array.prototype.newPush = function(val){\n        console.log('arr被修改了')\n        this.push(val)\n    }\n    arr.newPush(4)\n ```\n\n- 在上面这个例子中，我们针对数组的原生push方法定义个一个新的newPush方法，这个newPush方法内部调用了原生push方法，这样就保证了新的newPush方法跟原生push方法具有相同的功能，而且我们还可以在新的newPush方法内部干一些别的事情，比如通知变化， **Vue内部就是这样实现的** 。\n\n##### 数组方法拦截器\n\n- 经过整理，Array原型中可以改变数组自身内容的方法有7个，分别是：<kbd>push</kbd>，<kbd>pop</kbd>，<kbd>shift</kbd>，<kbd>unshift</kbd>，<kbd>splice</kbd>，<kbd>sort</kbd>，<kbd>reverse</kbd>。那么源码中的拦截器代码如下：\n\n ```js\n    // 源码位置：/src/core/observer/array.js\n    const arrayProto = Array.prototype\n    // 创建一个对象作为拦截器\n    export const arrayMethods = Object.create(arrayProto)\n    // 改变数组自身内容的7个方法\n    const methodsToPatch = [\n        'push',\n        'pop',\n        'shift',\n        'unshift',\n        'splice',\n        'sort',\n        'reverse'\n    ]\n    /**\n     * Intercept mutating methods and emit events\n     */\n    methodsToPatch.forEach(function (method) {\n        const original = arrayProto[method]      // 缓存原生方法\n        Object.defineProperty(arrayMethods, method, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value:function mutator(...args){\n            const result = original.apply(this, args)\n                return result\n            }\n        })\n    })\n ```\n\n- 在上面的代码中，首先创建了继承自Array原型的空对象arrayMethods，接着在arrayMethods上使用object.defineProperty方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用push方法的时候，其实用的是arrayMethods.push，而arrayMethods.push就是封装的新函数mutator，也就后说，实标上执行的是函数mutator，而mutator函数内部执行了original函数，这个original函数就是Array.prototype上对应的原生方法。 那么，接下来我们就可以在mutator函数中做一些其他的事，比如说发送变化通知。\n\n##### 使用拦截器\n\n- 把它挂载到数组实例与 **Array.prototype** 之间，这样拦截器才能够生效，其实挂载不难，我们只需把数据的<u>&nbsp;&nbsp;&nbsp;&nbsp;</u>proto<u>&nbsp;&nbsp;&nbsp;&nbsp;</u>属性设置为拦截器 **arrayMethods** 即可，源码实现如下：\n\n ```js\n    // 源码位置：/src/core/observer/index.js\n    export class Observer {\n        constructor (value) {\n            this.value = value\n            if (Array.isArray(value)) {\n                const augment = hasProto\n                    ? protoAugment\n                    : copyAugment\n                augment(value, arrayMethods, arrayKeys)\n            } else {\n                this.walk(value)\n            }\n        }\n    }\n    // 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性\n    export const hasProto = '__proto__' in {}\n    const arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n    /**\n     * Augment an target Object or Array by intercepting\n     * the prototype chain using __proto__\n     */\n    function protoAugment (target, src: Object, keys: any) {\n        target.__proto__ = src\n    }\n    /**\n     * Augment an target Object or Array by defining\n     * hidden properties.\n     */\n    /* istanbul ignore next */\n    function copyAugment (target: Object, src: Object, keys: Array<string>) {\n        for (let i = 0, l = keys.length; i < l; i++) {\n            const key = keys[i]\n            def(target, key, src[key])\n        }\n    }\n ```\n\n- 上面代码中首先判断了浏览器是否支持<kbd><u>&nbsp;&nbsp;&nbsp;&nbsp;</u>proto<u>&nbsp;&nbsp;&nbsp;&nbsp;</u></kbd>，如果支持，则调用protoAugment函数把value.<u>&nbsp;&nbsp;&nbsp;&nbsp;</u>proto<u>&nbsp;&nbsp;&nbsp;&nbsp;</u> = arrayMethods；如果不支持，则调用copyAugment函数把拦截器中重写的7个方法循环加入到value上。\n\n- 拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对Array型数据的可观测。\n\n#### 收集依赖\n\n##### 把依赖收集在哪里\n\n- 数组数据的依赖也在**getter**中收集，而给数组数据添加**getter/setter**都是在**Observer**类中完成的，所以我们也应该在**Observer**类中收集依赖，源码如下：\n\n```js\n// 源码位置：/src/core/observer/index.js\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    this.dep = new Dep()    // 实例化一个依赖管理器，用来收集数组依赖\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n```\n\n在**Observer**类中实例化了一个依赖管理器，用来收集数组依赖。\n\n##### 如何收集依赖\n\n- 数组的依赖也在getter中收集，那么在getter中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在Observer类中，而我们需要在getter中收集依赖，也就是说我们必须在getter中能够访问到Observer类中的依赖管理器，才能把依赖存进去。源码是这么做的：\n\n```js\nfunction defineReactive (obj,key,val) {\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get(){\n      if (childOb) {\n        childOb.dep.depend()\n      }\n      return val;\n    },\n    set(newVal){\n      if(val === newVal){\n        return\n      }\n      val = newVal;\n      dep.notify()   // 在setter中通知依赖更新\n    }\n  })\n}\n/**\n * 尝试为value创建一个Observer实例，如果创建成功，直接返回新创建的Observer实例。\n * 如果 Value 已经存在一个Observer实例，则直接返回它\n */\nexport function observe (value, asRootData){\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n- 在上面代码中，我们首先通过observe函数为被获取的数据arr尝试创建一个Observer实例，在observe函数内部，先判断当前传入的数据上是否有<kbd>\\_\\_ob\\_\\_</kbd>属性，因为在上篇文章中说了，如果数据有<kbd>\\_\\_ob\\_\\_</kbd>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用**new Observer(value)**将其转化成响应式的，并把数据对应的Observer实例返回。\n\n- 而在defineReactive函数中，首先获取数据对应的Observer实例childOb，然后在getter中调用Observer实例上依赖管理器，从而将依赖收集起来。\n\n##### 如何通知依赖\n\n- 到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？\n\n- 其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据value即可，因为vaule上的\\_\\_ob\\_\\_就是其对应的Observer类实例，有了Observer类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的dep.notify()方法，让它去通知依赖更新即可。源码如下：\n\n```js\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n- 上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的this就是数据value，拿到value上的Observer类实例，从而你就可以调用Observer类实例上面依赖管理器的dep.notify()方法，以达到通知依赖的目的。\n\n#### 深度侦测\n\n- 在前文所有讲的Array型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在Vue中，不论是Object型数据还是Array型数据所实现的数据变化侦测都是深度侦测，所谓**深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化**。举个例子：\n\n```js\nlet arr = [\n  {\n    name:'NLRX'，\n    age:'18'\n  }\n]\n```\n\n- 数组中包含了一个对象，如果该对象的某个属性的变化被侦测到的话，就是深度侦测。源码如下：\n\n```js\nexport class Observer {\n  value: any;\n  dep: Dep;\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)   // 将数组中的所有元素都转化为可被侦测的响应式\n    } else {\n      this.walk(value)\n    }\n  }\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\nexport function observe (value, asRootData){\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n- 在上面代码中，对于Array型数据，调用了observeArray()方法，该方法内部会遍历数组中的每一个元素，然后通过调用observe函数将每一个元素都转化成可侦测的响应式数据。\n\n- 而对应object数据，在defineReactive函数中进行了递归操作。\n\n#### 数组新增元素的侦测\n\n- 对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。\n\n- 这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用observe函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：push、unshift、splice。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：\n\n```js\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素\n        break\n      case 'splice':\n        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素\n        break\n    }\n    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n- 在上面拦截器定义代码中，如果是push或unshift方法，那么传入参数就是新增的元素;如果是splice方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用observe函数将新增的元素转化成响应式的了。\n\n#### 总结\n\n- 首先我们分析了对于Array型数据也在getter中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现Vue不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。\n\n- **以上就是对Array型数据的变化侦测分析。**","tags":["前端","vue","面试"],"categories":["前端","vue"]},{"title":"js判断数据类型的方式","url":"/2021/03/25/JS/js判断数据类型/","content":"\n首先定义几种类型的变量：\n\n```js\nlet num = 100\nlet str = 'hahaha'\nlet flag = true\nlet obj = {\n  name: 'xiaozhao',\n  age: 11,\n}\nlet arr = [1, 2, 3]\nlet reg = /ssss/\nlet fn = () => {\n  console.log(0)\n}\n```\n\n### 1、typeof\n\n```js\n/**\n * typeof:\n *      经常用来判断基本数据类型 boolean undefined string number symbol\n *      而 null、Array、Object 检测出来都是object\n */\nconsole.log(typeof num) // number\nconsole.log(typeof str) // string\nconsole.log(typeof flag) // boolean\nconsole.log(typeof obj) // object\nconsole.log(typeof arr) // object\nconsole.log(typeof reg) // object\nconsole.log(typeof fn) // function\n```\n\n### 2、instanceof\n\n```js\n/**\n * instanceof:\n *      经常用来判断复杂数据类型（引用数据类型）：Array、Object、RegExp\n *      原理是利用 判断对象的原型链中是否含有指定数据类型\n */\nconsole.log(num instanceof Number) // false\nconsole.log(str instanceof String) // false\nconsole.log(flag instanceof Boolean) // false\nconsole.log(obj instanceof Object) // true\nconsole.log(arr instanceof Array) // true\nconsole.log(reg instanceof RegExp) // true\nconsole.log(fn instanceof Function) // true\n```\n\n### 2、Object.prototype.toString.call()\n\n```js\n/**\n * Object.prototype.toString.call()\n *      可以准确地判断所有的数据类型\n */\nconsole.log(Object.prototype.toString.call(num)) // [object Number]\nconsole.log(Object.prototype.toString.call(str)) // [object String]\nconsole.log(Object.prototype.toString.call(flag)) // [object Boolean]\nconsole.log(Object.prototype.toString.call(obj)) // [object Object]\nconsole.log(Object.prototype.toString.call(arr)) // [object Array]\nconsole.log(Object.prototype.toString.call(reg)) // [object RegExp]\nconsole.log(Object.prototype.toString.call(fn)) // [object Function]\n```\n","tags":["js","面试"],"categories":["前端","js"]},{"title":"flex弹性布局","url":"/2021/03/15/CSS/css-flex/","content":"\n### 弹性布局\n\n#### 1.父级节点\n\n```css\n.parentNode {\n  display: flex;\n}\n/* \n如果节点设置了此css属性，相当于在它的所有子节点上添加了浮动属性；\n如果父级节点使用了弹性布局，那么它的子结点就不需要添加float属性\n*/\n```\n\n#### 2.父节点的其他属性\n\n##### （1）justify-content\n\n```css\n.parentNode {\n  display: flex;\n  justify-content: center; /* 设置子元素水平居中 */\n  justify-content: space-between; /* 设置子元素两端对齐 */\n  justify-content: space-around; /* 设置子元素都有独自的左右距离 */\n  justify-content: flex-start; /* 设置子元素水平居左，此为默认属性 */\n  justify-content: flex-end; /* 设置子元素水平居右 */\n}\n```\n\n##### （2）align-items\n\n```css\n.parentNode {\n  display: flex;\n  align-items: center; /* 设置子元素垂直居中 */\n  align-items: flex-start; /* 设置子元素垂直居上 */\n  align-items: flex-end; /* 设置子元素垂直居下 */\n}\n```\n\n##### （3）align-content\n\n```css\n/* 此属性只对多行子元素生效 */\n.parentNode {\n  display: flex;\n  align-content: center; /* 设置子元素垂直居中 */\n  align-content: flex-start; /* 设置子元素垂直居上 */\n  align-content: flex-end; /* 设置子元素垂直居下 */\n  align-content: stretch; /* 拉伸 ，默认值 */\n}\n```\n\n##### （4）flex-direction\n\n```css\n/* 此属性设置子元素的排列方向 */\n.parentNode {\n  display: flex;\n  flex-direction: row; /* 子元素横向排列 */\n  flex-direction: row-reverse; /* 子元素横向倒序排列 */\n  flex-direction: column; /* 子元素纵向排列 */\n  flex-direction: column-reverse; /* 子元素纵向倒序排列 */\n}\n/* 这里需要注意：当你设置了子元素纵向排列方向后，前两个属性也会随着改变方向！！！ */\n```\n\n##### （5）flex-wrap\n\n```css\n/* 此属性设置子元素是否正常换行 */\n.parentNode {\n  display: flex;\n  flex-wrap: wrap; /* 子元素正常换行 */\n  flex-wrap: nowrap; /* 子元素不换行 默认值 */\n}\n/* 这里需要注意：当你设置了子元素纵向排列方向后，前两个属性也会随着改变方向！！！ */\n```\n\n##### （6）flex-flow\n\n```css\n/* 设置子元素纵向排列正常换行 */\n.parentNode {\n  display: flex;\n  flex-flow: column warp;\n}\n/* 相当于（4）和（5）的组合 */\n```\n\n#### 3.子元素上的属性\n\n```css\n.children {\n  flex: 1; /* 用来设置每个节点的宽度，子元素在划分父级宽度的时候，会先排除固定的宽度 */\n  align-self: flex-start; /* 此属性可以覆盖父节点的align-items的垂直排列 */\n  flex-grow: 1; /* 设置元素的放大比例，默认值为0 */\n  order: 0; /* 规定子元素的排列顺序，数值越小越靠前 默认值为0 */\n}\n```\n","tags":["前端","css","flex","布局"],"categories":["前端","css","布局"]},{"title":"vue中连接MQTT服务器","url":"/2021/03/03/Vue/vue-MQTT/","content":"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。**\n\n#### 在vue项目中连接MQTT服务器\n\n##### 1.命令行安装mqtt\n\n``` npm install mqtt --save ```\n\n##### 2.项目中导入mqtt\n\n``` import mqtt from 'mqtt' ```\n\n##### 3.使用\n\n```javascript\n<template>\n  <div>\n    <van-nav-bar title=\"MQTT服务器连接测试\" left-arrow />\n    <van-button type=\"primary\" size=\"small\" @click=\"connectServer\" block>\n      点击连接mqtt服务器\n    </van-button>\n    <van-button type=\"danger\" size=\"small\" @click=\"endServer\" block>\n      点击断开\n    </van-button>\n    <van-button type=\"info\" size=\"small\" @click=\"sendContent\" block>\n      发送信息\n    </van-button>\n    <van-popup round closeable position=\"bottom\" v-model=\"showSubscribe\">\n      <van-cell-group style=\"margin: 10px 0\">\n        <van-field v-model=\"subscribe1\" label=\"订阅号\" placeholder=\"请输入订阅号\" />\n        <van-field v-model=\"username\" label=\"用户名\" placeholder=\"请输入用户名\" />\n        <van-field v-model=\"url\" label=\"连接地址\" placeholder=\"请输入地址Url\" />\n      </van-cell-group>\n      <van-button type=\"info\" size=\"small\" @click=\"connect\" block>点击连接</van-button>\n    </van-popup>\n    <van-popup round closeable position=\"bottom\" v-model=\"showContent\">\n      <van-cell-group>\n        <van-field v-model=\"subscribe2\" label=\"订阅号\" placeholder=\"请输入订阅号\" />\n        <van-field\n          v-model=\"message\"\n          label=\"信息\"\n          rows=\"3\"\n          autosize\n          type=\"textarea\"\n          maxlength=\"50\"\n          placeholder=\"请输入要发送的信息\"\n          show-word-limit\n        />\n      </van-cell-group>\n      <van-button type=\"info\" size=\"small\" @click=\"send\" block>点击发送</van-button>\n    </van-popup>\n  </div>\n</template>\n<script>\nimport mqtt from 'mqtt';\nexport default {\n  data() {\n    return {\n      client: null,\n      subscribe1: '',\n      subscribe2: '',\n      username: '',\n      url: 'ws://address:port', // ip地址和端口\n      message: '',\n      showSubscribe: false,\n      showContent: false,\n    }\n  },\n  methods: {\n    connectServer() {\n      this.showSubscribe = true\n    },\n    connect(){\n      console.log(\"连接中。。\")\n      var _this = this;\n      // 连接mqtt服务器\n      this.client = mqtt.connect(this.url, {\n        connectTimeout: 5000,\n        clientId: '小赵老弟',\n        username: this.username,\n        // password: 'zzdy123.',\n        clean: true\n      })\n      // 连接成功之后的监听\n      this.client.on('connect', (e) => {\n        console.log(\"连接成功！！！\", e)\n        // 订阅主题\n        _this.client.subscribe(this.subscribe1, {qos: 0}, (error) => { \n          if (!error) {\n            console.log('订阅成功')\n            this.showSubscribe = false\n          } else {\n            console.log('订阅失败')\n            _this.client.end()\n          }\n        })\n      })\n      // 接收消息处理\n      this.client.on('message', (topic, res) => {\n        // console.log('收到来自', topic, '的消息', JSON.stringify(res))\n        const resData = res.toString()\n        // 处理接收到的数据\n        console.log('接收到消息',resData)\n      })\n      this.client.on('close',(e) => {\n        console.log(\"断开连接！！！\", e)\n      })\n    },\n    sendContent() {\n      this.message = ''\n      this.showContent = true;\n    },\n    send() {\n      this.client.publish(this.subscribe2,this.message)\n      this.showContent = false;\n    },\n    /** 断开连接 */\n    endServer() {\n      this.client.end()\n    },\n  },\n}\n</script>\n```\n\n##### 4.参考文档\n\n[参考文档 mqtt-npm](https://www.npmjs.com/package/mqtt#handleMessage)","tags":["vue","通讯"],"categories":["前端","vue"]},{"title":"JS中常见的几种报错类型","url":"/2021/02/15/JS/js运行中常见错误/","content":"\n## JS 中常见的几种报错类型\n\n### 1、SyntaxError（语法错误）\n\n解析代码时发生的语法错误：\n\n```js\nvar 1a;                 //Uncaught SyntaxError: Invalid or unexpected token 变量名错误\nconsole.log 'hello');   //Uncaught SyntaxError: Unexpected string 缺少括号\n```\n\n### 2、ReferenceError（引用错误）\n\n```js\nconsole.log(a);     //Uncaught ReferenceError: a is not defined 引用了一个不存在的变量\nconsole.log()= 1;   //Uncaught ReferenceError: Invalid left-hand side in assignment 将变量赋值给一个无法被赋值的对象\n```\n\n### 3、RangeError（范围错误）\n\n```js\nvar a = new Array(-1) //Uncaught RangeError: Invalid array length 超出有效范围\n```\n\n### 4、TypeError（类型错误）\n\n变量或参数不是预期类型，比如，对字符串、布尔值、数值等原始类型的值使用 new 命令，就会抛出这种错误，因为 new 命令的参数应该是一个构造函数。\n\n```js\nvar a = new 123() //Uncaught TypeError: 123 is not a function\n```\n\n调用对象不存在的方法\n\n```js\nvar a\na.aa() //Uncaught TypeError: Cannot read property 'aa' of undefined\n```\n\n### 5、URLError（URL 错误）\n\n与 url 相关函数参数不正确，主要是 **encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和 unescape()** 这六个函数。\n\n```js\ndecodeURI('%2') //Uncaught URIError: URI malformed\n```\n\n### 6、EvalError（eval 错误）\n\neval 函数没有被正确执行\n\n### 7、手动抛出异常\n\n以上这 6 种派生错误，连同原始的 Error 对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。\n\n```js\nthrow new Error('出错了！')\nthrow new RangeError('出错了，变量超出有效范围！')\nthrow new TypeError('出错了，变量类型无效！')\n```\n\n> 上面代码表示新建错误对象的实例，实质就是手动抛出错误。可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。\n","tags":["前端","js"],"categories":["前端","js"]},{"title":"websocket知识了解","url":"/2021/02/13/websocket-topic/","content":"\n### websocket 是什么？\n\n- webscoket 是 HTML5 提供的协议，支持持久连接，而 HTTP 不支持持久连接，实现了浏览器和客户端的全双工通信，也就是在浏览器向服务器发送数据的同时服务器也可以向浏览器发送数据，是一种在单个 TCP 连接上传输的全双工通信协议；\n\n- webscoket 是基于 HTTP 协议的，或者说是借用了 HTTP 协议来完成一部分握手\n\n  ```header\n  GET /chat HTTP/1.1\n  Host: http://127.0.0.1:8000\n  Upgrade: websocket\n  Connection: Upgrade\n  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n  Sec-WebSocket-Version: 13\n  ```\n\n> 与一般的 http 握手相比是多了 Upgrade 和 Connection , 目的是为了告诉服务器发送的是 websocket\n\n### 在项目开发过程中为什么会使用到 websocket 技术\n\n- 手机或者网站上会出现一些需要实时更新的数据以及资源，这时如果我们高频次的向服务器发送请求来获取新数据也可以实现效果，但是当数据长时间未发生变化的时候，这种方法就会大量的浪费资源，是不可取的，websocket 刚好可以解决这个问题；\n\n### TCP 和 UDP 的区别\n\n- 特点：首先 TCP 是面向连接的可靠传输，在数据传输过程中是安全的，使用流量控制和拥塞控制；UDP 是无连接的不可靠传输，数据传输是不安全的，会出现丢包的现象；\n\n- TCP 只支持一对一的传输，UDP 不仅支持一对一，还有一对多、多对多传输；\n\n- 传输方式：TCP 面向字节流； UDP 面向报文\n\n- 头部开销：TCP 最小 20 字节最大 60 字节；UDP 仅 8 字节\n\n- 适用场景：TCP 安全，常用于文件传输； UDP 适用于实时应用（IP 电话，视频通话，直播）\n\n### socket 和 websocket 的区别\n\n- socket 是应用层与 TCP/IP 协议通信的中间软件抽象层，它是一组接口。而 WebSocket 则不同，它是一个完整的应用层协议，包含一套标准的 API。\n\n- 相比来说 socket 更灵活，webscoket 使用更简单方便；\n\n### websocket 和 http 的区别\n\n- websocket 协议是在 http 的基础上进行的；\n\n- http 协议是短连接，在客户端发送请求的时候建立连接，请求结束之后连接断开，下次请求需要重新建立连接；\n\n- websocket 协议是长连接，只在初始化的时候建立一次连接，之后客户端和服务端的请求和响应都是通过这个 TCP 链接来进行的；\n","tags":["面试","通讯","websocket"],"categories":["前端"]},{"title":"vue项目中使用mock模拟接口返回数据","url":"/2020/12/25/Vue/vue-mock-js/","content":"\n**我们在项目开发过程中经常会使用前后端分离的方式，但是当后台接口没有完成的情况下，前端开发可能会出现卡壳的情况，为了解决这个问题，我们可以使用mockjs来解决；**\n\n#### 1.使用npm安装mock.js\n\n```js\nnpm install mockjs --save-dev\n```\n\n#### 2.创建mock.js文件\n\n![mock.js文件](mock01.jpg)\n\n- **mock.js内容如下：**\n\n  ```js\n  import Mock from 'mockjs';  // 引入mockjs\n  import users from '../assets/jsonData/user.json'  // 这个是模拟数据库的json数据\n  // 通过Mock.mock函数模拟登录接口\n  Mock.mock('/api/login', 'post', function (options) {\n    // 这里的option是请求的相关参数   options.body是请求携带的参数（字符串）\n    let data = JSON.parse(options.body)\n    var results = users.filter( (item, index) => {\n      return item.loginName == data.loginName && item.password == data.password\n    })\n    if(results.length > 0){\n      return Mock.mock({\n        code: 200,\n        message: '登陆成功',\n        data: results[0]\n      })\n    }else {\n      return Mock.mock({\n        code: 400,\n        message: '账号或密码错误，登陆失败'\n      })\n    }\n  })\n  ```\n\n#### 3.main.js文件引入\n\n```js\nrequire('./mock') //将上面创建的js文件全局引入\n```\n\n#### 4.vue中调用接口\n\n```js\n<template>\n  <div class=\"container\">\n  </div>\n</template>\n<script>\nimport axios from 'axios'\nexport default {\n  name: 'Login',\n  data() {\n    return {\n      loginName: '',\n      password: ''\n    };\n  },\n  created() {\n    // 这里使用axios发送请求\n    axios.post('/api/login',{\n      loginName: 'xiaozhao',\n      password: '971122'\n    }).then( res => {\n      console.log(res) //打印结果看下图\n    })\n  }\n}\n</script>\n```\n\n![mock.js文件](mock02.jpg)\n\n#### 5.上面提到的user.json内容\n\n```json\n[\n  {\n    \"loginName\": \"xiaozhao\",\n    \"password\": \"971122\",\n    \"nickName\": \"小赵\"\n  },\n  {\n    \"loginName\": \"xiaojun\",\n    \"password\": \"970612\",\n    \"nickName\": \"小君\"\n  }\n]\n```\n\n> 注意：mock模拟出来的接口在发送请求时是不能在浏览器的network中看到的\n","tags":["vue","mockjs"],"categories":["前端","vue"]},{"title":"js基础题","url":"/2020/12/15/JS/basic-js/","content":"\n### 如何准确的判断复杂数据类型\n\n```js\nfunction judgeType(opt) {\n  return Object.prototype.toString.call(opt)\n}\nconsole.log(judgeType([])) //  [object Array]\n```\n\n### 如何将多维数组进行扁平化处理\n\n```js\n// 扁平化处理就是将多维数组转化为一维数组\n// 1.通过扩展运算符\nfunction flatten(arr) {\n  // 判断arr中是否含有Array,如果有就通过扩展运算符将二维数组转为一维数组，直到元素中不含有数组\n  while (arr.some((item) => Array.isArray(item))) {\n    arr = [].concat(...arr)\n  }\n}\nconsole.log(flatten([1, 2, [3, [4, 5]]])) // [1,2,3,4,5]\n// 2.通过递归的方式\nfunction flatten(arr) {\n  let res = []\n  arr.map((item) => {\n    if (Array.isArray(item)) {\n      res = res.concat(flatten(item))\n    } else {\n      res.push(item)\n    }\n  })\n  return res\n}\nconsole.log(flatten([1, 2, [3, [4, 5]]])) // [1,2,3,4,5]\n```\n\n### 封装一个方法，排序对象数组\n\n```js\nlet arr = [\n  { name: 'xiaozhao', age: 16 },\n  { name: 'xiaozhang', age: 14 },\n  { name: 'xiaowang', age: 17 },\n]\n/**\n * 我们要用到 sort() 函数，自定义排序规则\n */\nfunction objectSort(property) {\n  return function (m, n) {\n    let a = m[property]\n    let b = n[property]\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n}\nconsole.log(arr.sort(objectSort('name')))\nconsole.log(arr.sort(objectSort('age')))\n//[{name: \"xiaozhao\", age: 14},{name: \"xiaozhang\", age: 16},{name: \"xiaowang\", age: 17}]\n```\n","tags":["js","面试"],"categories":["前端","js"]},{"title":"jQuery实现导航锚点定位","url":"/2020/12/11/nav-location/","content":"\n### jQuery实现导航锚点定位\n\n[预览地址](https://www.jq22.com/yanshi23494)\n\n![效果展示](01.png)\n\n#### 1、创建html写如下代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <link rel=\"stylesheet\" href=\"./css/main.css\" />\n    <title>导航锚点定位</title>\n  </head>\n  <body>\n    <nav class=\"menu\">\n      <ol>\n        <li id=\"content1\" class=\"menu-item active\">\n          <a href=\"javascript:void(0);\">目录1</a>\n        </li>\n        <li id=\"content2\" class=\"menu-item\">\n          <a href=\"javascript:void(0);\">目录2</a>\n        </li>\n        <li id=\"content3\" class=\"menu-item\">\n          <a href=\"javascript:void(0);\">目录3</a>\n        </li>\n        <li id=\"content4\" class=\"menu-item\">\n          <a href=\"javascript:void(0);\">目录4</a>\n        </li>\n        <li id=\"content5\" class=\"menu-item\">\n          <a href=\"javascript:void(0);\">目录5</a>\n        </li>\n        <li id=\"content6\" class=\"menu-item\">\n          <a href=\"javascript:void(0);\">目录6</a>\n        </li>\n      </ol>\n    </nav>\n    <div class=\"container-div\">\n      <div class=\"text content1\">\n        内容1\n      </div>\n      <div class=\"text content2\">\n        内容2\n      </div>\n      <div class=\"text content3\">\n        内容3\n      </div>\n      <div class=\"text content4\">\n        内容4\n      </div>\n      <div class=\"text content5\">\n        内容5\n      </div>\n      <div class=\"text content6\">\n        内容6\n      </div>\n    </div>\n    <script src=\"./js/jquery.min.js\"></script>\n    <script src=\"./js/index.js\"></script>\n  </body>\n</html>\n```\n\n#### 2、创建css文件写如下样式\n\n```css\n* {\n  box-sizing: border-box;\n}\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n}\n:root {\n  --accent-color: #45494E;\n  --gradient-color: #FBFBFB;\n}\na:after {\n  content: \"\";\n  background: #FBFBFB;\n  position: absolute;\n  bottom: 5px;\n  left: 15px;\n  height: 3px;\n  width: 0;\n  transition: .5s;\n  transition-delay: .2s;\n}\n.menu {\n  position: fixed;\n  top: 100px;\n  left: 100px;\n  width: 100px;\n  font-size: 12px;\n  z-index: 999;\n}\n.menu > ol {\n  list-style: none;\n  padding: 0;\n}\n.menu > ol > li {\n  background: #3c3c3c;\n  border-left: 5px solid var(--gradient-color);\n  margin-bottom: 1px;\n  position: relative;\n  transition: .5s;\n}\n.menu > ol > li:nth-child(1) {\n  --accent-color: #FDA085;\n  --gradient-color: #F6D365;\n}\n.menu > ol > li:nth-child(2) {\n  --accent-color: #BFF098;\n  --gradient-color: #6FD6FF;\n}\n.menu > ol > li:nth-child(3) {\n  --accent-color: #EA8D8D;\n  --gradient-color: #A890FE;\n}\n.menu > ol > li:nth-child(4) {\n  --accent-color: #D8B5FF;\n  --gradient-color: #1EAE98;\n}\n.menu > ol > li:nth-child(5) {\n  --accent-color: #C6EA8D;\n  --gradient-color: #FE90AF;\n}\n.menu > ol > li:nth-child(6) {\n  --accent-color: #8dbaea;\n  --gradient-color: #FE90AF;\n}\n.menu > ol > li a {\n  color: #FBFBFB;\n  display: block;\n  padding: 15px;\n  position: relative;\n  text-decoration: none;\n  z-index: 1;\n}\n.menu > ol > .active:after {\n  background: linear-gradient(to left, var(--accent-color), var(--gradient-color));\n  max-width: 800px;\n}\n.menu > ol > li:focus .sub-menu,\n.menu > ol > li:focus-within .sub-menu {\n  max-height: 500px;\n}\n.menu > ol > li:after {\n  background: #3c3c3c;\n  content: \"\";\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  transition: .5s;\n  max-width: 0;\n  overflow: hidden;\n}\n\na:hover:after {\n    width: 50px;\n}\na:after {\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n.active > a:after {\n    width: 50px;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n.menu > ol {\n    display: block;\n    max-width: none;\n    text-align: center;\n}\n.menu > ol > li {\n    border-top: 5px solid var(--accent-color);\n    border-left: 0;\n    display: inline-block;\n    margin-left: -5px;\n    vertical-align: top;\n    width: 150px;\n}\n.menu > ol > .active:after {\n    background: linear-gradient(to bottom, var(--accent-color), var(--gradient-color));\n    border-radius: 3px;\n    top: -5px;\n    bottom: -5px;\n    left: -5px;\n    right: -5px;\n}\n\n.container-div {\n  margin: 0;\n  padding: 0;\n}\n.content1 {\n  padding: 0 250px;\n  height: 700px;\n  background: -webkit-linear-gradient(to bottom, #fda0856b, #f6d36585);\n  background: linear-gradient(to bottom, #fda0856b, #f6d36585);\n}\n.content2 {\n  padding: 0 250px;\n  height: 700px;\n  background: -webkit-linear-gradient(to bottom, #bff0986b, #6fd6ff85);\n  background: linear-gradient(to bottom, #bff0986b, #6fd6ff85);\n}\n.content3 {\n  padding: 0 250px;\n  height: 700px;\n  background: -webkit-linear-gradient(to bottom, #ea8d8d6b, #a890fe85);\n  background: linear-gradient(to bottom, #ea8d8d6b, #a890fe85);\n}\n.content4 {\n  padding: 0 250px;\n  height: 700px;\n  background: -webkit-linear-gradient(to bottom, #d8b5ff6b, #1eae9885);\n  background: linear-gradient(to bottom, #d8b5ff6b, #1eae9885);\n}\n.content5 {\n  padding: 0 250px;\n  height: 700px;\n  background: -webkit-linear-gradient(to bottom, #c6ea8d6b, #fe90af85);\n  background: linear-gradient(to bottom, #c6ea8d6b, #fe90af85);\n}\n.content6 {\n  padding: 0 250px;\n  height: 700px;\n  background: -webkit-linear-gradient(to bottom, #8dbaea6b, #fe90af85);\n  background: linear-gradient(to bottom, #8dbaea6b, #fe90af85);\n}\n```\n\n#### 3、创建js文件写如下代码\n\n```js\n$(function(){\n  $('ol li').click(function(){\n      // 页面平滑的滚动到相应的位置\n      scrollToTop($(\".\"+$(this).attr(\"id\")).offset().top)\n  })\n  /* 监听滚动 */\n  $(document).scroll(function() {\n    if ($(document).height() <= (parseInt($(document).scrollTop() + 1) + $(window).height())){  //滚动条滑到底部啦\n      $(\"ol li\").removeClass('active')\n      $(\"ol li:last\").addClass('active')\n      return;\n    }\n    var top = $(document).scrollTop();  //滚动条距离顶部的高度\n    $(\".text\").each(function (i,item) {\n        if($(this).offset().top <= top){\n            $(\"ol li\").removeClass('active')\n            $(\"#\"+item.classList[1]).addClass('active');\n        }\n    })\n  });\n})\n/** 将滚动轴滚到相应位置 */\nfunction scrollToTop(number) {\n  window.scrollTo({\n      top: number,\n      behavior: \"smooth\"\n  });\n}\n```\n","tags":["插件"],"categories":["前端"]},{"title":"前端每日基础题","url":"/2020/12/05/DailyTopic/","content":"\n### 2020-12-05\n\n#### 用递归算法实现，数组长度为 5 且元素的随机数在 2-32 间不重复的值\n\n解：\n\n```js\nvar nums = new Array(5) // 先创建长度为5的数组\nvar count = 0 // 定义count当作数组的索引来使用\ngetRandomNums(nums) // 调用方法\nfunction getRandomNums(array) {\n  if (count >= array.length) {\n    // 首先判断索引 如果索引等于数组的长度就调出递归\n    console.log(array) // 打印最终结果后退出\n    return false\n  }\n  var data = Math.round(Math.random() * 30 + 2) // 生成2-32的随机数\n  if (array.indexOf(data) == -1) {\n    // 判断数组中不存在这个随机数将随机数放在索引为 count 的位置上\n    array[count] = data\n    count++ // 存入数据之后索引加 1\n  }\n  getRandomNums(array) //继续调用形成递归\n}\n```\n\n#### 说说对圣杯布局和双飞翼布局的理解和区别\n\n- 两种布局方式都是两边固定，中间自适应的三栏布局，中间栏放在文档流前面优先渲染；\n\n- 圣杯布局：为了中间部分不被遮挡，采用中间栏设置 **<font color=\"#249caf\">padding-left</font>** 和 **<font color=\"#249caf\">padding-right</font>** 后，将左右两栏通过相对布局 **<font color=\"#249caf\">position: relative;配合 left right</font>** 的方式固定在两边；\n\n- 双飞翼布局：为了中间部分不被遮挡，中间采用两个 div 做嵌套，子 div 设置**<font color=\"#249caf\">margin-left</font>** 和 **<font color=\"#249caf\">margin-right</font>** 给左右两边留出位置；\n\n#### 页面导入样式时，使用 link 和@import 有什么区别\n\n- link 是 HTML 标签，@import 是 css 提供的语法；\n\n- link 引入的样式页面加载时同时加载，@import 引入的样式需等页面加载完成后再加载；\n\n- link 没有兼容性问题，@import 不兼容 ie5 以下；\n\n- link 可以通过 js 操作 DOM 动态引入样式表改变样式，而@import 不可以；\n\n### 2020-12-07\n\n#### 用 css 画一条 0.5px 的直线\n\n- 这个题是考验 CSS3 的 <font color=\"#249caf\">transform</font>\n\n  ```html\n  <!DOCTYPE html>\n  <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\" />\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n      <title>Document</title>\n      <style>\n        .main {\n          height: 1px;\n          width: 1px;\n          background-color: black;\n          transform: scale(0.5); /* css的2D缩放转换 */\n        }\n      </style>\n    </head>\n    <body>\n      <div class=\"main\"></div>\n    </body>\n  </html>\n  ```\n\n#### 用 css 设置水平垂直居中\n\n- 水平居中：\n\n  ```css\n  /* 1.行级元素 */\n  .box {\n    text-align: center;\n  }\n  /* 2.块级元素 */\n  .box {\n    margin: 0 auto;\n  }\n  /* 3.flex弹性布局 */\n  .box {\n    display: flex;\n    justify-content: center;\n  }\n  /* 4.绝对定位配合transform */\n  .box {\n    position: absolute;\n    left: 50%;\n    transform: translateX(-50%);\n  }\n  ```\n\n- 垂直居中：\n\n  ```css\n  /* 1.设置line-height的值为元素的高度 */\n  .box {\n    line-height: 100px;\n  }\n  /* 2.flex弹性布局 */\n  .box {\n    display: flex;\n    align-items: center;\n  }\n  /* 3.绝对定位配合transform */\n  .box {\n    position: absolute;\n    top: 50%;\n    transform: translateY(50%);\n  }\n  /* 4.display: table的方式 */\n  .main {\n    /* 父元素 */\n    height: 500px;\n    display: table;\n  }\n  .content {\n    /* 子元素 */\n    display: table-cell;\n    vertical-align: middle;\n  }\n  ```\n\n#### css 的 @support、@media 和 calc 的区别\n\n- @support 主要是用于检测浏览器是否支持 CSS 的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补；\n\n- @media 查询可以针对不同的媒体类型定义不同的样式；\n  @media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的；\n  当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面；\n\n- calc()函数用于动态计算长度，支持 '+'、 '-'、 '\\*'、 '/'、 四种计算方式\n\n#### 用 js 写出一个去掉字符串空格的方法\n\n- 使用正则表达式的方法\n\n  ```js\n  // 删除字符串左右两端的空格\n  function trim(str) {\n    return str.replace(/(^\\s*)|(\\s*$)/g, '')\n  }\n  // 删除左端空格\n  function leftTrim(str) {\n    return str.replace(/(^\\s*)/g, '')\n  }\n  // 删除右端空格\n  function rightTrim(str) {\n    return str.replace(/(\\s*$)/g, '')\n  }\n  // 删除所有空格\n  function allTrim(str) {\n    return str.replace(/\\s/g, '')\n  }\n  console.log(trim(' he l l o   ')) // \"he l l o\"\n  console.log(leftTrim(' he l l o   ')) // \"he l l o   \"\n  console.log(rightTrim(' he l l o   ')) // \" he l l o\"\n  console.log(allTrim(' he l l o   ')) // \"hello\"\n  ```\n\n#### 列举出常用的 html 标签\n\n| 块儿级元素 |      描述      | 行级元素 |              描述              |\n| :--------: | :------------: | :------: | :----------------------------: |\n|    div     | 常用的块级容器 |   span   | 常用的行内元素，定义文本内区块 |\n|   h1~h6    |      标题      |    a     |          锚点、超链接          |\n|     hr     |   水平分割线   |    b     |          文字内容加粗          |\n|    menu    |    菜单列表    |  strong  |        文字内容加粗强调        |\n|     ol     |    有序列表    |    i     |          文字内容斜体          |\n|     ul     |    无序列表    |    em    |        文字内容斜体强调        |\n|     li     |     列表项     |    br    |            强制换行            |\n|     dl     |    定义列表    |  input   |           文本输入框           |\n|   table    |      表格      | textarea |         多行文本输入框         |\n|     p      |      段落      |   img    |            引入图片            |\n|    form    |    交互表单    |  select  |            下拉列表            |\n\n### 2020-12-08\n\n#### 1rem、1em、1vh、1px 各自代表的含义？\n\n- **rem**： 表示相对于根节点 **<font color=\"#249caf\">&lt;HTML&gt;</font>** 的长度;\n  通常情况下：我们给 <font color=\"#249caf\">&lt;HTML&gt;</font> 设置字体大小，页面中其他长度就可以使用 <font color=\"#249caf\">rem</font>；\n\n- **em**：子元素的字体大小是相对于父元素的 <font color=\"#249caf\">font-size</font> 来表示的；\n  元素的 width、height、padding、margin 使用 **em** 是相对于该元素的 <font color=\"#249caf\">font-size</font>;\n\n- **vw**/**vh**：Viewport Width 和 Viewport Height，表示视窗的宽度和高度，我经常配合<font color=\"#249caf\">calc()</font>函数使用；\n\n- **px**：相对长度单位，具体长度根据显示器的分辨率确定，常见的显示器分辨率为 <font color=\"#249caf\">1920×1080</font>；\n\n#### 说一下盒模型\n\n- **<font color=\"#249caf\">盒模型</font>** 是一种常用的页面布局方式，由内向外的结构为：**content** &gt; **padding** &gt; **border** &gt; **margin**;\n\n- 标准的盒模型的 **width** 是 **content** 的宽度： `box-sizing: content-box;`\n\n- IE 的盒模型的 **width** 是 **content + padding + border** 的宽度：`box-sizing: border-box;`\n\n### 2020-12-09\n\n#### 用 css 画一个三角形\n\n> 我们通常会用组件库进行开发，但原生的 css 还是需要掌握的\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      /* 三角形 */\n      .triangle {\n        width: 0;\n        height: 0;\n        border-width: 100px;\n        border-style: solid;\n        border-color: transparent #0099cc transparent transparent;\n        transform: rotate(90deg);\n      }\n    </style>\n  </head>\n  <body>\n    <!-- 三角形 -->\n    <div class=\"triangle\"></div>\n  </body>\n</html>\n```\n\n### 2020-12-12\n\n#### CSS BFC\n\n- **<font color=\"#249caf\">block formatting context</font>** ：块级格式化上下文；\n\n- **bfc**：是一个独立的渲染区域，只有 block-level box 参与，它规定了内部的 block-level box 如何布局，并且与这个区域外部毫不相干。\n\n- **如何创建 BFC**：\n  满足以下任何一点都可以创建 bfc\n\n  - **float** 属性不为 **none**；\n  - **overflow** 属性不为 **visible**（可以是**hidden**、**scoll**、**auto**）；\n  - **position** 为 **absolute**或**fixed**；\n  - **display** 为 **inline-block**、**table-cell**、**table-caption**\n\n- **BFC 的作用**\n\n  - **清除内部浮动**\n    我们在布局时经常会遇到这个问题：对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把把父元素变成一个 BFC 就行了。常用的办法是给父元素设置 overflow:hidden；\n  - **垂直 margin 合并**\n    在 CSS 当中，相邻的两个盒子的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距;\n    - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值;\n    - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值;\n    - 两个外边距一正一负时，折叠结果是两者的相加的和;\n\n  > **这里的两个盒子必须是垂直相邻的**；\n\n### 2020-12-16\n\n#### **label** 标签的用法\n\n- **label** 标签的的主要作用是为了扩大可点击范围，增加用户体验；\n\n#### 遍历 a 节点下的所有子节点\n\n```js\nlet a = document.getElementById('id')\nvar list = a.parentNode.children\nconsole.log(list)\n```\n\n#### js 用递归的方式写 1-100 求和\n\n```js\nvar sum = 0\nfunction getSum(i) {\n  if (i == 101) {\n    return sum\n  }\n  sum += i\n  i++\n  getSum(i)\n}\nconsole.log(getSum(1, 0)) // 5050\n```\n\n#### HTML 页面的渲染过程\n\n- 构建 **<font color=\"#249caf\">DOM</font>** 树\n  将 Html 所有节点构建成 DOM 树，把所有节点构建出来；\n\n- 构建 **<font color=\"#249caf\">CSSOM</font>** 树\n  解析 CSS 来构建 CSSOM 树；\n\n- 构建 **<font color=\"#249caf\">render</font>** 树\n  有了 DOM 树和 CSSOM 树之后，浏览器会根据 DOM 树和 CSSOM 树来构建 render 树，从而知道了有哪些节点，每个节点的位置和 css 样式以及各个节点的从属关系；\n\n- 布局\n  render 树有了之后，浏览器就开始计算各个节点的位置和样式；\n\n- 绘制页面\n  遍历 render 树，在页面上绘制每个节点；\n\n- 页面 **<font color=\"#249caf\">回流 reflow</font>** 和 **<font color=\"#249caf\">重绘 repaint</font>**\n  有时候 javascript 中会有对 dom 节点和 css 的操作，这时候就需要重新构建 render 树；\n  **<font color=\"#249caf\">回流</font>**: 当 render 树中的一部分(或全部)因为元素的尺寸，布局，隐藏等改变而需要重新构建；\n  回流之后就会进行重绘;\n  **<font color=\"#249caf\">重绘</font>**：当只是元素的外观，风格变化，不影响布局的，重新渲染的过程就叫重绘。\n\n#### HTML 解析过程中 js、css、dom 的加载顺序\n\n- 首先我们都知道 HTML 是按照 **<font color=\"#249caf\">从上往下</font>** 的顺序进行加载的；\n\n- 如果遇到 **<font color=\"#249caf\">link</font>** 和 **<font color=\"#249caf\">style</font>** ，就会去下载这些 css 资源，但是 css 和 dom 的构建是 **<font color=\"#249caf\">并行的</font>** ，因此 css 资源的加载并不会阻塞 dom 树的构建；\n\n- **<font color=\"#249caf\">如果遇到 script，那么页面就会把控制权交给 JavaScript</font>，直到脚本加载完成或者构建完毕才会继续向下进行**；\n\n- 页面绘制依靠的是 render 树，因此如果<font color=\"#249caf\">DOM 树和 CSSOM 树未构建完成，页面是不会显示的</font>；\n\n- JavaScript 执行过程中可能会对 css 进行操作，所以在 css 加载的时候会对 script 进行阻塞的；\n\n> 注意：我们在写 HTML 页面的时候一般会把 css 放在页面头部，js 放在页面底部，是因为 js 中可能会出现操作 DOM 的情况，如果把 js 放在 dom 元素前面，那么按照加载顺序来看的话，js 阻塞了 DOM 树的构建，当 js 在操作 DOM 的时候 DOM 树还不存在，这时就会抛出异常；\n\n### 2020-12-18\n\n#### js 如何中断 ajax 请求\n\n- 第一种方式：在 ajax 中 **<font color=\"#249caf\">设置超时时间</font>**，可以让 ajax 自动断开\n\n- 第二种方式：调用 **<font color=\"#249caf\">XMLHttpRequest</font>** 对象上的 **<font color=\"#249caf\">abort()</font>** 方法\n\n#### target 和 currentTarget 的区别\n\n- **<font color=\"#249caf\">target</font>** 表示点击的节点\n\n- **<font color=\"#249caf\">currentTarget</font>** 表示触发事件的节点\n\n#### 说一下事件代理(事件委托)\n\n- 事件代理是指将事件绑定到 **<font color=\"#249caf\">指定元素的父元素上</font>**，利用 **<font color=\"#249caf\">事件的冒泡机制</font>** 让指定元素触发事件；\n\n- 优点：当 **<font color=\"#249caf\">重复元素特别多</font>** 的时候（例如：li），不需要循环绑定事件，可以很大程度的减少对 dom 的操作，提高页面性能；\n\n  ```js\n  window.onload = function () {\n    var list = document.getElementById('ul1')\n    list.onclick = function (ev) {\n      var ev = ev || window.event\n      var target = ev.target || ev.srcElement\n      if (target.nodeName.toLowerCase() == 'li') {\n        console.log(target.innerHTML)\n      }\n    }\n  }\n  ```\n\n### 2020-12-19\n\n#### javascript 的宏任务和微任务\n\n- **<font color=\"#249caf\">宏任务(macrotask)</font>**：当前执行栈中执行的任务就是宏任务，常见的有 <font color=\"#249caf\">script 主代码块儿、定时器</font> 等；\n\n- **<font color=\"#249caf\">微任务(microtask)</font>**：在当前宏任务执行结束后，下一个宏任务开始之前执行的任务是微任务，常见的就是 promise 函数；\n\n- 宏任务的宿主是 <font color=\"#249caf\">浏览器或 node</font>、微任务的宿主是 <font color=\"#249caf\">js 引擎</font>\n\n### 2020-12-28\n\n#### export 和 export default 的区别\n\n- **export** 的用法：\n\n  ```js\n  /** 直接导出  */\n  export let words = 'hello world!!!'\n  export function output() {}\n  /** 先定义在导出 */\n  let data = 'hahaha';\n  export data;\n  ```\n\n- **export default** 的用法\n\n```js\n/** 只能直接导出，而且一个文件中只能出现一次,不能先定义后导出  */\nexport default function output() {}\n```\n\n- 两种方式的 **import** 是不一样的\n\n  ```js\n  // export\n  import { words, output, data } from 'export'\n  // export default\n  import output from 'export default'\n  ```\n\n#### 什么是闭包\n\n- 闭包的实质是：**通过函数的嵌套而形成的作用域链**；\n\n- 闭包的定义：**函数 A** 的**内部**有一个 **函数 B**，**函数 B** 中可以访问到 **函数 A** 的变量，那么 **函数 B 就是闭包**；\n\n  ```js\n  /** 例 1 */\n  function funA() {\n    var a = 10 // funA的活动对象之中;\n    return function () {\n      //匿名函数的活动对象;\n      console.log(a)\n    }\n  }\n  var b = funA()\n  b() // 10\n  ```\n\n  ```js\n  /** 例 2 */\n  function outerFn() {\n    var i = 0\n    console.log('外', i)\n    function innerFn() {\n      i++\n      console.log('内', i)\n    }\n    return innerFn\n  }\n  /** 每次外部函数执行的时候,都会开辟一块内存空间,\n  外部函数的地址不同，都会重新创建一个新的地址 */\n  var inner = outerFn() // 外  0\n  inner() // 内  1\n  inner() // 内  2\n  inner() // 内  3\n  var inner2 = outerFn() // 外  0\n  inner2() // 内  1\n  inner2() // 内  2\n  inner2() // 内  3\n  ```\n\n- **闭包的特点：**\n\n  - 让外部访问函数内部变量成为可能；\n  - 局部变量会常驻在内存中；\n  - 可以避免使用全局变量，防止全局变量污染；\n  - 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）\n\n#### 什么是 cookie，什么是会话 cookie，什么是持久性 cookie\n\n- **什么是 cookie：**\n  Cookie 是 Web 服务器发送到浏览器的数据字符串。 当浏览器在将来请求来自同一个域的对象时，该浏览器会将同一日期字符串发送回原始服务器，该数据以一个称为“Set-Cookie”的 HTTP 报头格式从 Web 服务器发出。 浏览器以称为“Cookie”的 HTTP 报头格式将 cookie 发送回服务器。\n\n- **会话 cookie：**\n  当 cookie 中没有到期时间的时候，可视为会话 cookie，会话 cookie 的信息只会保存在内存中，当浏览器关闭时，cookie 信息就会永久丢失；\n\n- **持久性 cookie：**\n  当 cookie 中有到期时间的时候，是持久性 cookie，cookie 的信息会保存在磁盘中，在指定的到期日期，cookie 会自动删除；\n\n### 2020-12-29\n\n#### js 中数组条件查询的方法(find、findIndex、indexOf、lastIndexOf 、includes)\n\n- **<font color=\"#249caf\">find()</font>**：返回数组中满足判断条件的第一个元素；\n\n  ```js\n  // 返回数组中 >= 15 的第一个元素\n  var arr = [0, 1, 2, 3, 15, 14, 32]\n  var num = arr.find((item) => {\n    return item >= 15\n  })\n  console.log(num) // 15\n  ```\n\n- **<font color=\"#249caf\">findIndex()</font>**：返回数组中满足判断条件的第一个元素的索引，不存在返回-1；\n\n  ```js\n  // 返回数组中 >= 15 的第一个元素的索引\n  var arr = [0, 1, 2, 3, 15, 14, 32]\n  var num = arr.findIndex((item) => {\n    return item >= 15\n  })\n  console.log(num) // 4\n  ```\n\n- **<font color=\"#249caf\">indexOf()</font>**：返回数组中找到给定元素第一次出现的索引，不存在返回-1；\n\n  ```js\n  // 返回数组中第一个15的索引\n  var arr = [0, 1, 2, 3, 15, 14, 32]\n  var num = arr.indexOf(15) // 默认是从索引为0的位置往后查找\n  var num1 = arr.indexOf(15, 4) // 从索引为4的位置往后查找\n  var num2 = arr.indexOf(15, 10) // 从索引为10的位置往后查找\n  console.log(num) // 4\n  console.log(num1) // 4\n  console.log(num2) // -1\n  ```\n\n- **<font color=\"#249caf\">lastIndexOf()</font>**：返回数组中找到给定元素最后一次出现的索引，不存在返回-1；\n\n  ```js\n  // 返回数组中第一个15的索引\n  var arr = [0, 1, 2, 5, 3, 5, 14, 32]\n  var num = arr.lastIndexOf(5) // 默认是从索引为arr.length-1的位置向前查找\n  var num1 = arr.lastIndexOf(5, 4) // 从索引为4的位置向前查找\n  var num2 = arr.lastIndexOf(5, 1) // 从索引为1的位置向前查找\n  console.log(num) // 5\n  console.log(num1) // 3\n  console.log(num1) // -1\n  ```\n\n- **<font color=\"#249caf\">includes()</font>**：用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false\n\n  ```js\n  ;[0, 1, 2, 3, 4, 5, 6].includes(5) // true     从索引0位置往后查找是否存在5元素，是\n  ;[0, 1, 2, 3, 4, 5, 6].includes(10) // false\n  ;[0, 1, 2, 3, 4, 5, 6].includes(5, 10) // false    从索引10位置往后查找是否存在10元素，否\n  ```\n","tags":["前端"],"categories":["前端"]},{"title":"在Vue项目中使用wangEditor编辑器","url":"/2020/12/02/Vue/vue-wangEditor/","content":"\n### 1、在项目中安装 **wangEditor**\n\n使用 **npm** 安装：\n```\nnpm install wangeditor --save\n```\n\n### 2、创建组件wangEditor\n\n- 在components中创建文件夹wangEditor\n\n- 组件内容如下：\n\n```js\n<template>\n  <div class=\"editor\">\n    <div ref=\"toolbar\" class=\"toolbar\">\n      </div>\n    <div ref=\"editor\" class=\"text\">\n    </div>\n  </div>\n</template>\n<script>\n  import E from \"wangeditor\"\n  export default {\n    name: 'editor',\n    data(){\n      return{\n        content:\"\",\n        editor: null,\n        info_: null,\n        isChange: false\n      }\n    },\n    model: {\n      prop: 'value',\n      event: 'change'\n    },\n    watch: {\n      isClear (val) {\n        // 触发清除文本域内容\n        if (val) {\n          this.editor.txt.clear()\n          this.info_ = null\n        }\n      },\n      value (val) {\n        // 这里的判断是为了解决编辑内容是光标乱跳的问题\n        if(!this.isChange){\n          this.editor.txt.html(this.value);\n        }\n        this.isChange= false;\n      }\n    },\n    props: {\n      value: {\n        type: String,\n        default: ''\n      },\n      isClear: {\n        type: Boolean,\n        default: false\n      }\n    },\n    mounted () {\n        this.seteditor()\n    },\n    methods:{\n      seteditor () {\n        this.editor = new E(this.$refs.toolbar, this.$refs.editor)\n        this.editor.customConfig = this.editor.customConfig ? this.editor.customConfig : this.editor.config;\n        // this.editor.customConfig.uploadImgShowBase64 = true // base 64 存储图片\n        this.editor.customConfig.uploadImgServer = process.env.VUE_APP_BASE_API// 配置服务器端地址\n        this.editor.customConfig.uploadImgHeaders = {   }// 自定义 header\n        this.editor.customConfig.uploadFileName = 'file' // 后端接受上传文件的参数名\n        this.editor.customConfig.uploadImgMaxSize = 2 * 1024 * 1024 // 将图片大小限制为 2M\n        this.editor.customConfig.uploadImgMaxLength = 6 // 限制一次最多上传 3 张图片\n        this.editor.customConfig.uploadImgTimeout = 3 * 60 * 1000 // 设置超时时间\n        // 配置菜单\n        this.editor.customConfig.menus = [\n          'head', // 标题\n          'bold', // 粗体\n          'fontSize', // 字号\n          'fontName', // 字体\n          'italic', // 斜体\n          'underline', // 下划线\n          'strikeThrough', // 删除线\n          'foreColor', // 文字颜色\n          'backColor', // 背景颜色\n          'link', // 插入链接\n          'list', // 列表\n          'justify', // 对齐方式\n          'quote', // 引用\n          // 'emoticon', // 表情\n          'image', // 插入图片\n          'table', // 表格\n          // 'video', // 插入视频\n          'code', // 插入代码\n          'undo', // 撤销\n          'redo' // 重复\n        ]\n        this.editor.customConfig.uploadImgHooks = {\n          fail: (xhr, editor, result) => {\n          // 插入图片失败回调\n          },\n          success: (xhr, editor, result) => {\n          // 图片上传成功回调\n          },\n          timeout: (xhr, editor) => {\n          // 网络超时的回调\n          },\n          error: (xhr, editor) => {\n          // 图片上传错误的回调\n          },\n          customInsert: (insertImg, result, editor) => {\n          // 图片上传成功，插入图片的回调\n          }\n        }\n        this.editor.customConfig.onchange = (html) => {\n          this.isChange = true;\n          this.info_ = html // 绑定当前逐渐地值\n          this.$emit('change', this.info_) // 将内容同步到父组件中\n        }\n        // 创建富文本编辑器\n        this.editor.create();\n        console.log(this.value)\n        this.editor.txt.html(this.value)\n      }\n    },\n  }\n</script>\n<style scoped>\n.editor {\n  margin: 0 auto;\n}\n.toolbar {\n  border: 1px solid #ccc;\n}\n.text {\n  border: 1px solid #ccc;\n  height: 350px;\n}\n</style>\n```\n\n### 3、父组件中调用方法\n\n代码如下：\n\n```js\n<template>\n  <div>\n    <wangEditor v-model=\"noticeContent\" @change=\"changeContent\" :isClear=\"isClear\" ></wangEditor>\n  </div>\n</template>\nimport wangEditor from '@/components/wangEditor';\nexport default {\n  components: { wangEditor },\n  data() {\n    return {\n      noticeContent: \"\",\n      content:\"\",\n      isClear: false//清除富文本编辑器内容\n    }\n  },  \n  methods: {\n    changeContent(val){\n      this.form.noticeContent = val;\n    },\n  }\n}\n```\n","tags":["前端","vue","插件"],"categories":["前端","vue"]},{"title":"vue-生命周期","url":"/2020/12/02/Vue/vue-lifecycle/","content":"\n### Vue生命周期详解\n\n#### 以下是一张官网的生命周期图示\n\n![vue生命周期](vue生命周期.jpg)\n\n#### 1、beforeCreate （vue实例创建前）\n\n在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此***无法访问 methods， data， computed 等上的方法和数据***;\n\n```js\nexport default {\n  data() {\n    return {\n      msg: 'linlin'\n    }\n  },  \n  methods: {\n    getLists(){\n      return 'aaa'\n    }\n  },\n  beforeCreate() {\n    console.log('beforeCreate',this.msg,this.getLists())\n  }\n}\n```\n\n运行上面代码之后控制台报错：\n\n![beforeCreate函数调用资源结果](01.png)\n\n因为就像前面说的这个钩子函数里拿不到 **data** 和 **methods**\n\n#### 2、created（vue实例创建后）\n\n- 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el属性目前不可见;\n\n- 这是一个常用的生命周期钩子，因为你可以调用 **methods** 中的方法，改变 **data** 中的数据，并且修改可以通过vue的响应式绑定体现在页面上，获取computed中的计算属性等等;\n\n  >应用场景： 异步数据的获取和对实例数据的初始化操作都可以在这里面进行;\n\n  ```js\n  export default {\n    data() {\n      return {\n        msg: 'linlin',\n        imgs: null\n      }\n    },  \n    methods: {\n      // 异步请求获取数据修改data中的数据\n      getLists(){\n        this.$http.get(url).then(res=>{\n          this.imgs = res.data.lists\n          console.log(this.imgs)\n        })\n      }\n    },\n    created() {\n      this.getLists()\n    }\n  }\n  ```\n\n#### 3、beforeMount\n\n- 挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了 **el** 和 **data** 初始化，注意此时还没有挂载html到页面上；\n\n- 因此：不论是 **created** 还是 **beforeMount** 在它们里面都拿不到真实的(也就是渲染完成后的)dom元素，如果我们需要拿到dom元素就需要在mounted里操作\n\n  ```js\n  <template>\n    <div>\n      <ul>\n        <li v-for=\"(item,index) in arr\" :key=\"index\">{{item}}</li>\n      </ul>\n    </div>\n  </template>\n  export default {\n    data() {\n      return {\n        arr: [1,2,3]\n      }\n    },  \n    methods: {\n      // 异步请求获取数据修改data中的数据\n      getLists(){\n        this.$http.get(url).then(res=>{\n          this.imgs = res.data.lists\n          console.log(this.imgs)\n        })\n      }\n    },\n    created() {\n      console.log('created',document.querySelectorAll('li').length)  // created 1\n    },\n    beforeMount() {\n      console.log('beforeMount',document.querySelectorAll('li').length)  // beforeMount 1\n    },\n    mounted() {\n      console.log('mounted',document.querySelectorAll('li').length)  // mounted 3\n    },\n  }\n  ```\n\n#### 4、mounted\n\n- 挂载完成，也就是模板中的 *HTML* 渲染到HTML页面中，此时一般可以做一些ajax操作;\n\n- mounted可以拿到dom元素，但也只是能拿到初始化数据里的dom元素，如果是存在异步对dom元素数据进行更改后渲染出来的dom元素这个时候是获取不到的，在 **updated** 钩子中可以获取到异步数据渲染到的dom节点\n\n- 应用场景：初始数据（在data中有的）的dom渲染完毕，可以获取dom\n\n  ```js\n  <template>\n    <div>\n      <ul>\n        <li v-for=\"(item,index) in arr\" :key=\"index\">{{item}}</li>\n      </ul>\n    </div>\n  </template>\n  export default {\n    data() {\n      return {\n        arr: [1,2,3]\n      }\n    },  \n    methods: {\n    },\n    created() {\n      setTimeout(()=>{\n        this.arr = [4,5,6,7]\n        console.log('created',document.querySelectorAll('li').length) // created 3\n      }, 1000)\n    },\n    mounted() {\n      console.log('mounted',document.querySelectorAll('li').length) // mounted 3\n    },\n    updated() {\n      console.log('mounted',document.querySelectorAll('li').length) // mounted 4\n    }\n  }\n  ```\n\n#### 5、beforeUpdate\n\n- 当数据更新后出发的钩子函数，这个钩子函数里拿到的是更改之前的数据，虚拟DOM重新渲染和打补丁之前被调用;\n\n- 可以在这个钩子中进一步地修改data，这不会触发附加的重渲染过程;\n\n#### 6、updated\n\n- 在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态(修改数据)，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用\n\n#### 7、beforeDestroy（销毁前）\n\n- 在实例销毁之前调用，实例仍然完全可用\n\n- 这一步还可以用this来获取实例\n\n- 一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件\n\n#### 8、destroyed（销毁后）\n\n在实例销毁之后调用，调用后，所有的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用;","tags":["vue","面试"],"categories":["前端","vue"]},{"title":"Linux-centos7安装MySQL数据库","url":"/2020/11/06/mysql-linux/","content":"\n#### 1、下载 **MySQL源** 的安装包\n\n``` wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm ```\n\n#### 2、安装 **MySQL源**\n\n``` yum localinstall mysql57-community-release-el7-8.noarch.rpm ```\n\n#### 3、检查 **MySQL源** 是否安装成功\n\n``` yum repolist enabled | grep \"mysql.*-community.*\" ```\n\n#### 4、安装**MySQL**\n\n``` yum install mysql-community-server ```\n\n![](mysql-linux01.jpg)\n如果之前安装过MySQL或者安装失败过的话会出现以上错误,解决方法：\n- 先执行：``` yum module disable mysql ```\n- 后继续执行：``` yum -y install mysql-community-server ```\n\n#### 5、修改**MySQL**登陆密码\n\n- 编辑 /etc/my.cnf ，在 [mysqld] 部分最后添加一行 \n``` skip-grant-tables ```\n\n- 保存后重启mysql \n``` service mysqld restart ```\n- 输入以下命令，回车后输入密码再回车登录Mysql \n``` mysql -uroot -p mysql ```\n- 重新设置密码，其中 pwd 部分改为你自己想要设置的密码\n``` update user set password=password(\"pwd\") where user='root'; ```\n- 刷新权限 ``` flush privileges; ```\n- 退出mysql 将前面添加的一行信息删除重新登录mysql\n\n#### 6、配置**MySQL**支持远程访问\n\n``` GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'pwd' WITH GRANT OPTION; ```\n``` FLUSH PRIVILEGES; ```\n\n#### 7、开放MySQL端口：3306\n\n这里是阿里云服务器：直接在阿里云控制台设置安全组\n![](mysql-linux02.jpg)\n\n#### 8、本地连接\n\n![](mysql-linux03.jpg)","tags":["mysql"],"categories":["linux"]},{"title":"webpack 学习笔记","url":"/2020/09/14/打包工具/webpack/","content":"\n# webpack 学习记录介绍\n\n## 一、**webpack** 简介\n\n### 1. **webpack** 是什么？\n\n- **webpack 是一种前端资源构建工具，是一个静态模块打包器（<font color=\"#a273d6\"> module bundler</font>）;**\n\n- **在 webpack 看来，前端的所有静态资源文件（js/json/css/img/less/……）都会被作为模块进行处理;**\n- **根据各个模块之间的依赖关系进行静态分析，打包生成对应的静态资源(<font color=\"#a273d6\">bundle</font>);**\n  ![](webpack01.jpg)\n\n### 2. **webpack** 的五个核心概念\n\n##### &emsp;2.1 Entry\n\n&emsp;&emsp;**入口（<font color=\"#a273d6\">Entry</font>）：**指示 webpack 以哪个文件为入口或起点开始打包以及分析构建内部依赖图;\n\n##### &emsp;2.2 Output\n\n&emsp;&emsp;**输出（<font color=\"#a273d6\">Output</font>）：**指示 webpack 打包后的资源<font color=\"#a273d6\">bundles</font>输出到哪里去，以及如何命名;\n\n##### &emsp;2.3 Loader\n\n&emsp;&emsp;**<font color=\"#a273d6\">Loader</font>：**让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只能处理 JavaScript）\n\n##### &emsp;2.4 Plugins\n\n&emsp;&emsp;**插件（<font color=\"#a273d6\">Plugins</font>）：**可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等;\n\n##### &emsp;2.5 Mode 模式\n\n&emsp;&emsp;**模式（<font color=\"#a273d6\">Mode</font>）**：指示 webpack 使用相应模式的配置，通过选择 <kbd>development</kbd> 或 <kbd>production</kbd> 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化;\n\n|        **选项**        |                                                                                                                                             **描述**                                                                                                                                              |                              **特点**                               |\n| :--------------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :-----------------------------------------------------------------: |\n| <kbd>development</kbd> |                                                                                    会将 <b>process.env.NODE_ENV</b> 的值设为 <b>development</b><br>启用 <b>NamedChunksPlugin</b> 和 <b>NamedModulesPlugin</b>                                                                                     | <b>开发环境</b>，也就是让开发者可以<br>对代码进行本地调试运行的环境 |\n| <kbd>production</kbd>  | 会将 <b>process.env.NODE_ENV</b> 的值设为 <b>production</b><br>启用 <b>FlagDependencyUsagePlugin</b>, <b>FlagIncludedChunksPlugin</b>,<br> <b>ModuleConcatenationPlugin</b>, <b>NoEmitOnErrorsPlugin</b>,<br> <b>OccurrenceOrderPlugin</b>, <b>SideEffectsFlagPlugin</b> 和 <b>UglifyJsPlugin</b> |               <b>生产环境</b>可以让代码上线运行的环境               |\n\n## 二、**webpack** 初体验\n\n### 1. 初始化配置\n\n##### &emsp;1.1 初始化 package.json\n\n&emsp;&emsp;<b>输入指令：`npm init`</b>\n\n##### &emsp;1.2 下载并安装 webpack\n\n&emsp;&emsp;<b>全局安装 webpack</b> 输入指令：`npm install webpack webpack-cli -g`\n\n&emsp;&emsp;<b>本地安装 webpack</b> 输入指令：`npm install webpack webpack-cli -D`\n\n### 2. 打包应用测试\n\n##### &emsp;2.1 开发环境打包\n\n- **webpack** 以 <font color=\"#a273d6\">./src/index.js</font> 为入口文件开始打包，打包后输出到 <font color=\"#a273d6\">./build/built.js</font>\n\n- 开发环境打包指令：`webpack ./src/index.js -o ./build/built.js --mode=development`\n\n##### &emsp;2.2 生产环境打包\n\n- 生产环境打包指令：`webpack ./src/index.js -o ./build/built.js --mode=production`\n\n##### &emsp;2.3 结论\n\n- webpack 可以直接处理 js 和 json 资源，不能处理 css/img 等其他资源;\n- 生产环境和开发环境可以将 ES6 的模块化语法转换成浏览器识别的模块化语法\n- 生产环境相比于开发环境多了一个压缩 js 代码的功能\n\n## 三、**webpack** 开发环境的基本配置\n\n### 1. 创建配置文件\n\n##### &emsp;1.1 创建文件 **<font color=\"#a273d6\">webpack.config.js</font>**\n\n##### &emsp;1.2 配置如下内容\n\n- **<font color=\"#a273d6\">webpack</font>** 最基础的配置\n\n```js\n/*\n * webpack.config.js 是webpack的配置文件\n * 作用：知识webpack做哪些工作（当你运行 webpack 指令的时候加载其中的配置）\n * 所有的构建工具都是基于nodeJs平台运行的，模块化默认采用commonjs\n */\nconst { resolve } = require('path') //node内置核心模块，用来处理路径问题\nmodule.exports = {\n  //webpack的配置\n  // 模式\n  mode: 'development', //开发模式\n  //mode: 'production'\n  //入口起点\n  entry: './src/index.js',\n  //输出\n  output: {\n    //输出文件名\n    filename: 'built.js',\n    //输出路径\n    path: resolve(__dirname, 'build'),\n  },\n  //Loader的配置\n  module: {\n    rules: [\n      // 详细的loader配置\n    ],\n  },\n  // 插件配置\n  plugins: [\n    // pligins详细配置\n  ],\n}\n```\n\n##### &emsp;1.3 运行指令 **<font color=\"#a273d6\">webpack</font>**\n\n##### &emsp;1.4 结论 **<font color=\"#a273d6\">同上</font>**\n\n### 2. 打包样式资源\n\n##### &emsp;2.1 创建以下文件：\n\n![](webpack02.jpg)\n\n##### &emsp;2.2 修改 webpack 配置文件如下：\n\n- 配置 **<font color=\"#a273d6\">loader</font>** 帮助打包 **<font color=\"#a273d6\">css、less</font>** 资源\n- **<font color=\"#a273d6\">loader</font>** 步骤：1.**<font color=\"#a273d6\">下载安装</font>** 2.**<font color=\"#a273d6\">使用</font>**\n\n```js\nconst { resolve } = require('path')\nmodule.exports = {\n  //webpack的配置\n  // 模式\n  mode: 'development', //开发模式\n  //mode: 'production'\n  //入口起点\n  entry: './src/index.js',\n  //输出\n  output: {\n    //输出文件名\n    filename: 'built.js',\n    //输出路径\n    path: resolve(__dirname, 'build'),\n  },\n  //Loader的配置\n  module: {\n    rules: [\n      // 详细的loader配置\n      // 不同的文件必须配置不同的loader\n      {\n        // 表示匹配那些文件\n        test: /\\.css$/,\n        // 使用哪些loader，use中loader的执行顺序是从右到左或者说是从下到上依次执行\n        use: [\n          // 创建一个style标签，将js的样式资源插入进去，添加到页面的head中生效\n          'style-loader',\n          // 将css文件变成commonjs模块加载到js中，内容是样式字符串\n          'css-loader',\n        ],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          // 将less文件编译成css文件\n          // 需要下载两个包 less less-loader\n          'less-loader',\n        ],\n      },\n    ],\n  },\n  // 插件配置\n  plugins: [\n    // pligins详细配置\n  ],\n}\n```\n\n##### &emsp;2.3 下载安装打包样式文件所需的 **<font color=\"#a273d6\">loader</font>** 包：\n\n- 输入以下指令：\n  ` npm install less-loader css-loader style-loader -D`\n- 如何项目中有 **<font color=\"#a273d6\">.less</font>** 文件，还需安装 **less**\n  ` npm install less -D`\n\n##### &emsp;2.4 运行指令：`webpack`\n\n### 3. 打包 HTML 文件\n\n##### &emsp;3.1 创建以下文件：\n\n![](webpack03.jpg)\n\n##### &emsp;3.2 编写 webpack 配置文件如下：\n\n- 配置 **<font color=\"#a273d6\">plugin</font>** 帮助打包 **<font color=\"#a273d6\">HTML</font>** 资源\n- 配置 **<font color=\"#a273d6\">plugin</font>** 步骤： 1.**<font color=\"#a273d6\">下载安装</font>** 2.**<font color=\"#a273d6\">引入</font>** 3.**<font color=\"#a273d6\">使用</font>**\n- 下载 **<font color=\"#a273d6\">html-webpack-plugin</font>** 插件：`npm install html-webpack-plugin -D `\n- 引入 **<font color=\"#a273d6\">html-webpack-plugin</font>** 插件：`const HtmlWebpackPlugin = require('html-webpack-plugin')`\n\n```js\nconst { resolve } = require('path')\n//引入html-webpack-plugin插件\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    filename: 'built.js',\n    path: resolve(__dirname, 'build'),\n  },\n  module: {\n    rules: [],\n  },\n  // 插件配置 步骤：1.下载 2.引入 3.使用\n  plugins: [\n    // 下载 html-webpack-plugin\n    // 功能：此插件默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）\n    // 需求：现在我们需要有结构的html\n    new HtmlWebpackPlugin({\n      //加上这个属性之后打包会复制'./src/index.html'文件并自动引入打包输出的所有资源（JS/CSS）\n      template: './src/index.html',\n    }),\n  ],\n}\n```\n\n### 4. 打包图片资源\n\n##### &emsp;4.1 创建以下目录结构：\n\n![](webpack04.jpg)\n\n##### &emsp;4.2 下载所需的包：\n\n- **<font color=\"#a273d6\">url-loader</font>**： `npm install url-loader -D `\n\n- **<font color=\"#a273d6\">file-loader</font>**： `npm install file-loader -D `\n- **<font color=\"#a273d6\">html-loader</font>**： `npm install html-loader -D `\n\n##### &emsp;4.3 文件配置：\n\n- **<font color=\"#a273d6\">index.html</font>**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>打包图片资源</title>\n  </head>\n  <body>\n    <div class=\"img1\"></div>\n    <div class=\"img2\"></div>\n    <div class=\"img3\"></div>\n    <img src=\"./img/angular.jpg\" alt=\"angular\" />\n  </body>\n</html>\n```\n\n- **<font color=\"#a273d6\">index.less</font>**\n\n```css\n.img1 {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background-image: url(./img/vue.jpg);\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n}\n.img2 {\n  float: left;\n  width: 200px;\n  height: 300px;\n  background-image: url(./img/angular.jpg);\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n}\n.img3 {\n  float: left;\n  width: 300px;\n  height: 500px;\n  background-image: url(./img/react.png);\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n}\n```\n\n- **<font color=\"#a273d6\">webpack.config.js</font>**\n\n```js\nconst { resolve } = require('path')\nconst HtmlWebpcakPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    filename: 'built.js',\n    path: resolve(__dirname, 'build'),\n  },\n  module: {\n    rules: [\n      {\n        // 打包css资源的loader配置\n        // 需要使用多个loader处理的话使用 use\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader'],\n      },\n      {\n        // 打包图片资源的loader配置 需要用到url-loader\n        // 使用单个loader处理使用 loader\n        test: /\\.(jpg|png|gif)$/,\n        // 需要下载两个包 url-loader file-loader\n        // 问题：这个loader默认情况下是不能处理html中的图片\n        loader: 'url-loader',\n        options: {\n          // 当图片大小小于8kb的话就会被转化成base64进行处理\n          // 优点：减少请求数量，减轻服务器压力\n          // 缺点：图片体积会更大（文件请求速度更慢一点）\n          limit: 8 * 1024,\n          // 给打包后的文件命名：hash的前十位以及原文件的扩展名\n          name: '[hash:10].[ext]',\n        },\n      },\n      {\n        test: /\\.html$/,\n        // 用来处理html文件中的img资源的（负责引入图片从而被url-loader进行处理）\n        loader: 'html-loader',\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpcakPlugin({\n      template: './src/index.html',\n    }),\n  ],\n}\n```\n\n### 5. 打包其他资源\n\n- 这里的其他资源是指除了之前打包的资源之外的其他资源；\n- 使用的 loader 是 **<font color=\"#a273d6\">file-loader</font>**；\n- 只需要在 **<font color=\"#a273d6\">webpack.config.js</font>** 的 module 配置中添加下面代码：\n\n```js\n{\n    // exclude 表示排除匹配的文件类型\n    exclude: /\\.(js|css|html|less)/,\n    loader: 'file-loader',\n    options: {\n        name: '[hash:10].[ext]'\n    }\n}\n```\n\n### 6. devServer 配置\n\n- 在我们实际开发过程中，我们是在一直修改 src 目录下的文件，目前我们学习的情况下，如果修改代码之后在浏览器查看效果的话，需要每次都执行 `webpack` 命令；\n\n- 解决这个问题我们需要使用开发服务器 **<font color=\"#a273d6\">devServer</font>** ,用来实现自动化,启动之后可以监控代码的变化，进而进行自动编译，自动刷新浏览器，集大程度的提高了我们的开发效率；\n- 安装 **<font color=\"#a273d6\">webpack-dev-server</font>**, 执行：`npm install webpack-dev-server -D`\n- 在 **<font color=\"#a273d6\">webpack.config.js</font>** 的 **<font color=\"#a273d6\">module.exports</font>** 配置中添加下面配置：\n\n```js\n// 开发服务器是运行在内存中的，因此每次更新编译的时候不会对output位置的东西进行修改\ndevServer: {\n    // 项目构建后的路径\n    contentBase: resolve(__dirname, 'build'),\n    // 启用gzip压缩\n    compress: true,\n    // 端口号\n    port: 3000,\n    // 启动后打开浏览器\n    open: true\n}\n```\n\n- 运行命令：`npx webpack-dev-server`\n\n### 7. 开发环境配置整合\n\n##### &emsp;7.1 创建以下文件：\n\n![](webpack05.jpg)\n\n##### &emsp;7.2 **<font color=\"#a273d6\">webpack.config.js</font>** 配置：\n\n- 以下配置有两种打包方式：\n  - **<font color=\"#a273d6\">webpack</font>**：打包后会输出项目结构；\n  - **<font color=\"#a273d6\">npx webpack-dev-server</font>**：打包后不会输出项目结构；\n\n```js\nconst { resolve } = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  // 开发模式配置\n  mode: 'development',\n  // 入口配置\n  entry: './src/js/index.js',\n  // 输出配置\n  output: {\n    filename: 'js/index.js',\n    path: resolve(__dirname, 'dist'),\n  },\n  // loader 配置\n  module: {\n    rules: [\n      {\n        // 处理css文件\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        // 处理less文件\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader'],\n      },\n      {\n        // 处理样式文件中的img路径\n        test: /\\.(jpg|png|gif)$/,\n        loader: 'url-loader',\n        options: {\n          limit: 8 * 1024,\n          name: '[hash:10].[ext]',\n          // 图片资源打包后放在imgs文件夹下\n          outputPath: 'imgs',\n        },\n      },\n      {\n        // 处理html中的img资源\n        test: /\\.html$/,\n        loader: 'html-loader',\n      },\n      {\n        // 处理其他资源\n        exclude: /\\.(html|js|css|less|jpg|png|gif)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[hash:10].[ext]',\n          outputPath: 'media',\n        },\n      },\n    ],\n  },\n  // 插件配置\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n    }),\n  ],\n  // devServer配置\n  devServer: {\n    contentBase: resolve(__dirname, 'dist'),\n    compress: true,\n    port: 3000,\n    open: true,\n  },\n}\n```\n\n##### &emsp;7.3 打包后输出的目录结构：\n\n![](webpack06.jpg)\n\n## 四、**webpack** 生产环境的基本配置\n\n### 1. 以上开发环境打包存在的一些问题\n\n##### &emsp;1.1 打包之后可能会出现闪屏现象：\n\n- 因为打包时通过**<font color=\"#a273d6\">css-loader</font>**之后是将 css 添加在 js 文件中，又经过**<font color=\"#a273d6\">style-loader</font>**创建 style 标签加入样式，当整个过程比较慢的时候页面会出现闪屏现象；\n- 安装插件：`npm install mini-css-extract-plugin`;\n- 配置文件做如下配置：(打包后将 css 文件提取出来通过 link 的方式引入页面)\n\n```js\nconst { resolve } = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugins = require('mini-css-extract-plugin')\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    filename: 'index.js',\n    path: resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 作用：这个loader将css单独提取出来,通过link标签引入html\n          MiniCssExtractPlugins.loader,\n          // 将css文件整合到js中\n          'css-loader',\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n    }),\n    new MiniCssExtractPlugins({\n      // 对输出的css文件进行重命名\n      filename: 'css/main.css',\n    }),\n  ],\n}\n```\n\n### 2. **<font color=\"#a273d6\">CSS</font>** 兼容性处理\n\n- 创建以下目录结构：\n  ![](webpack07.jpg)\n\n- 安装 <font color=\"#a273d6\">postcss-loader</font> `npm install postcss-loader -D`\n- 安装 <font color=\"#a273d6\">postcss-preset-env</font> `npm install postcss-preset-env -D`\n- 配置文件做以下配置：\n\n```js\nconst { resolve } = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst MiniCssExtractPlugins = require('mini-css-extract-plugin')\n// 设置nodejs的环境变量\nprocess.env.NODE_ENV = 'development'\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.js',\n  output: {\n    filename: 'js/index.js',\n    path: resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          MiniCssExtractPlugins.loader,\n          'css-loader',\n          /**\n                     * 要处理css兼容性问题，必须要使用postcss：postcss-loader,\n                     * 插件：postcss-preset-env 作用：帮助postcss在package.json中找到browserslist里面的配置，\n                     *      通过配置加载指定的css兼容性样式\n                     * \"browserslist\": {\n                     *      // 开发环境配置 --> 需要设置node的环境变量：process.env.NODE_ENV = 'development'\n                            \"development\": [\n                                \"last 1 chrome version\",\n                                \"last 1 firefox version\",\n                                \"last 1 safari version\"\n                            ],\n                            // 生产环境配置： 默认情况下都是生产环境配置\n                            \"production\": [\n                                \">0.2%\",\n                                \"not dead\",\n                                \"not op_mini all\"\n                            ]\n                        }\n                     */\n          // 使用loader的默认配置\n          //'postcss-loader',\n          // 修改loader的配置\n          {\n            loader: 'postcss-loader',\n            options: {\n              postcssOptions: {\n                // ident: 'postcss',\n                plugins: [require('postcss-preset-env')()],\n              },\n            },\n          },\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n    }),\n    new MiniCssExtractPlugins({\n      filename: 'css/main.css',\n    }),\n  ],\n}\n```\n\n- 修改 package.json\n\n```js\n\"browserslist\": {\n    \"development\": [\n        \"last 1 chrome version\",\n        \"last 1 firefox version\",\n        \"last 1 safari version\"\n    ],\n    \"production\": [\n        \">0.2%\",\n        \"not dead\",\n        \"not op_mini all\"\n    ]\n}\n```\n\n- 运行指令：`webpack`\n- 运行结果：我们发现<kbd>main.css</kbd>中的部分属性自动加上了浏览器前缀\n  ![dist目录结构](webpack08.jpg) ![main.css](webpack09.jpg)\n\n### 3. **<font color=\"#a273d6\">CSS</font>** 文件压缩处理\n\n- 安装插件 <font color=\"#a273d6\">optimize-css-assets-webpack-plugin</font> `npm install optimize-css-assets-webpack-plugin -D`\n\n- 在 <font color=\"#a273d6\">webpack.config.js</font> 的<kbd>plugins</kbd>中添加以下配置：\n\n```js\n// 文件上边引入插件\nconst OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')\n// plugins中添加下面配置\nnew OptimizeCssAssetsPlugin()\n```\n\n- 执行 `webpack`后我们发现打包后的 css 文件只有一行内容，并且所占内存缩小！\n\n### 4. **<font color=\"#a273d6\">eslint</font>** 对 js 进行语法检查\n\n- 安装以下插件：\n  `npm install eslint-config-airbnb-base eslint-plugin-import eslint-loader eslint -D`\n\n- 配置文件进行如下配置：\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { resolve } = require('path')\nmodule.exports = {\n  mode: 'development',\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/index.js',\n    path: resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      /**\n       *  语法检查 eslint-loader eslint\n       *  注意：只检查用户自己写的源代码，第三方的库是不检查的,\n       *  设置检查规则：\n       *      在package.json的eslintConfig中设置\n       *      \"eslintConfig\": {\n       *          \"extends\": \"airbnb-base\"\n       *      }\n       *  我们需要安装的东西：eslint-config-airbnb-base  eslint-plugin-import eslint-loader eslint\n       */\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'eslint-loader',\n        options: {\n          // 自动修复eslint的错误\n          fix: true,\n        },\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n    }),\n  ],\n}\n```\n\n- <font color=\"#a273d6\">package.json</font> 添加以下配置\n\n```js\n\"eslintConfig\": {\n    \"extends\": \"airbnb-base\"\n}\n```\n\n### 5. js 兼容性处理\n\n- 下载安装包：\n  `npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env -D`\n\n- 配置文件进行如下配置：\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { version } = require('os')\nconst { resolve } = require('path')\nmodule.exports = {\n  mode: 'development',\n  entry: './src/js/index.js',\n  output: {\n    filename: 'js/index.js',\n    path: resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      /**\n       * js兼容性处理：安装 npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env -D\n       * 1.基本的兼容性处理 --> @babel/preset-env\n       *      问题：只能转换基本语法（如：promise）不能转换\n       * 2.全部的js兼容性处理 --> @babel/polyfill3(目前不考虑)\n       *      问题：我只需要解决部分兼容性问题，但是这个方法将锁头的兼容性代码全部引入，体积太大\n       * 3.需要做兼容性处理的叫做：按需加载 --> core-js\n       */\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n        options: {\n          // 预设：指示babel做怎样的兼容性处理\n          presets: [\n            [\n              '@babel/preset-env',\n              {\n                // 按需加载\n                useBuiltIns: 'usage',\n                //指定core-js的版本\n                corejs: {\n                  version: 3,\n                },\n                // 兼容性做到哪个版本浏览器\n                targets: {\n                  chrome: '60',\n                  firefox: '60',\n                  ie: '9',\n                  safari: '10',\n                  edge: '17',\n                },\n              },\n            ],\n          ],\n        },\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n    }),\n  ],\n}\n```\n","tags":["前端","webpack"],"categories":["前端"]},{"title":"VSCode常用快捷键","url":"/2020/09/07/vsCodeShortcutKey/","content":"\n## VSCode常用快捷键\n\n### 编辑器与窗口管理\n\n1. 新建文件：&#9;<kbd>Ctrl</kbd>+<kbd>N</kbd>\n\n2. 文件之间切换：&#9;<kbd>Ctrl</kbd>+<kbd>Tab</kbd>\n3. 打开一个新的VS Code编辑器：&#9;<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>N</kbd>\n4. 关闭当前窗口：&#9;<kbd>Ctrl</kbd>+<kbd>W</kbd>\n5. 关闭当前的VS Code编辑器：&#9;<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>W</kbd>\n6. 切换左中右3个编辑器窗口：&#9;<kbd>Ctrl</kbd>+<kbd>1</kbd>、<kbd>Ctrl</kbd>+<kbd>2</kbd>、<kbd>Ctrl</kbd>+<kbd>3</kbd>\n\n### 代码编辑\n\n#### 格式调整\n\n1. 代码向左或向右缩进：&#9;<kbd>Ctrl</kbd>+<kbd>[</kbd> 、<kbd>Ctrl</kbd>+<kbd>]</kbd>\n\n2. 代码格式化：&#9;<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>L</kbd>\n3. 向上或向下移动一行：&#9;<kbd>Alt</kbd>+<kbd>up</kbd>、<kbd>Alt</kbd>+<kbd>down</kbd>\n4. 向上或向下复制一行: &#9;<kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>Up</kbd>、<kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>Down</kbd>\n5. 在当前行下方插入一行: &#9;<kbd>Ctrl</kbd>+<kbd>Enter</kbd>\n6. 在当前行上方插入一行: &#9;<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Enter</kbd>\n\n#### 光标调整\n\n1. 移动到行首：&#9;<kbd>Home</kbd>\n\n2. 移动到行尾：&#9;<kbd>End</kbd>\n3. 移动到文件结尾：&#9;<kbd>Ctrl</kbd>+<kbd>End</kbd>\n4. 移动到文件开头：&#9;<kbd>Ctrl</kbd>+<kbd>Home</kbd>\n5. 移动到定义处：&#9;<kbd>F12</kbd>\n6. 查看定义处缩略图(只看一眼而不跳转过去)：&#9;<kbd>Alt</kbd>+<kbd>F12</kbd>\n7. 选择从光标到行尾的内容：&#9;<kbd>Shift</kbd>+<kbd>End</kbd>\n8. 选择从光标到行首的内容：&#9;<kbd>Shift</kbd>+<kbd>Home</kbd>\n9. 删除光标右侧的所有内容(当前行)：&#9;<kbd>Ctrl</kbd>+<kbd>Delete</kbd>\n10. 扩展/缩小选取范围：&#9;<kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>Right</kbd>和<kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>Left</kbd>\n11. 多行编辑(列编辑)：&#9;<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>左键</kbd>和<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Down或Up</kbd>\n12. 同时选中所有匹配编辑(与当前行或选定内容匹配)：&#9;<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>L</kbd>\n\n\n","tags":["开发工具"],"categories":["开发工具"]},{"title":"ES6语法的实用方法","url":"/2020/08/07/JS/ES6/","content":"\n### 隐藏 HTML 中指定的元素\n\n<br>\n\n```js\n//定义一个方法 hide\nconst hide = (el) => Array.from(el).forEach((e.style.display = 'none'))\n//调用此方法并且传入要隐藏的元素 ' 隐藏页面中所有的<img>元素 '\nhide(document.querySelectorAll('img'))\n```\n\n> <font color=\"#0b7309\">效果如下：</font>\n> ![](ES601.jpg)\n\n### 检查元素是否含有指定的类\n\n<br>\n页面DOM里的每个节点都有一个<font color=\"red\">classList</font>对象，程序员可以使用里面的方法新增、删除、修改节点上的<font color=\"red\">class</font>,包括节点是否被赋予了某个<font color=\"red\">class</font>\n\n```js\n//定义一个方法 hasClass, 判断el是否含有className\nconst hasClass = (el, className) => el.classList.contains(className)\n//调用函数\nhasClass(document.querySelector('p.special'), 'special')\n```\n\n> <font color=\"#0b7309\">效果如下：</font>\n> ![](ES602.jpg)\n\n### 切换一个元素的类 class\n\n<br>\n\n```js\n//定义一个方法 toggleClass\nconst toggleClass = (el, className) =>\n  el.classList.replace(el.className, className)\n//调用此方法并且传入元素和替换的className\ntoggleClass(document.querySelector('span.active'), 'unactive')\n```\n\n例：\n\n```html\n<style>\n    div{\n        height: 100vh;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    }\n    .active{\n        border-radius: 40px;\n        height: 300px;\n        width: 300px;\n        background-color: red;\n    }\n    .unactive{\n        border-radius: 40px;\n        height: 300px;\n        width: 300px;\n        background-color: #CCCCCC;\n    }\n</style>\n<body>\n    <div>\n        <span class=\"active\"></span>\n    </div>\n</body>\n</html>\n```\n\n> <font color=\"#0b7309\">效果如下：</font>\n> ![](ES603.jpg)\n\n### 获取当前页面的滚动位置\n\n<br>\n\n```js\n//el代表window对象，\n//pageXOffset返回文档在窗口左上角水平方向滚动的像素\n//pageYOffset返回文档在窗口左上角垂直方向滚动的像素\nconst getScrollPosition = (el = window) => ({\n  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,\n})\n//调用\ngetScrollPosition()\n```\n\n> <font color=\"#0b7309\">效果如下：</font>\n> ![](ES604.jpg)\n\n### 将页面平滑的滚动到顶部\n\n<br>\n\n```js\nconst scrollToTop = () => {\n  //这里用到js中的或运算 ‘ || ’如果前边的存在返回前边的，否则返回后边的\n  const c = document.documentElement.scrollTop || document.body.scrollTop\n  if (c > 0) {\n    //requestAnimationFrame是html5提供的用于请求动画的，请求动画帧\n    //它的有点是：由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿\n    window.requestAnimationFrame(scrollToTop)\n    window.scrollTo(0, c - c / 8)\n  }\n}\n// 事例\nscrollToTop()\n```\n\n> **window.requestAnimationFrame()** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n> **requestAnimationFrame**：优势：由系统决定回调函数的执行时机。60Hz 的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿。\n\n### 展开运算符\n\n顾名思义，用于对象或数组之前的展开操作符（…），将一个结构展开为列表。演示一下：\n\n> 用法 1：合并数组或者向数组中添加元素\n\n```js\n//使用展开运算符\nlet firstHalf = [  1 ,  2 ];\nlet secondHalf = [ 3 ,  4 , ...firstHalf];\n//不用展开运算符\nlet firstHalf = [  1 ,  2 ];\nlet secondHalf = [ 3 ,  4 ];\nfor(var i=0, i <firstHalf.length; i++ )\n{\n    secondHalf.push(firstHalf[i]);\n}\n```\n\n> 用法 2：传参或接收不确定的参数\n\n```js\n//传参\nfunction test(a, b) {\n  return a + b\n}\nvar arr = [1, 2]\nconsole.log(test(...arr)) // 3\n\n//接收不确定的参数\nfunction test(...m) {\n  var s = 0\n  for (var i of m) {\n    s = s + i\n  }\n  return s\n}\nconsole.log(test(1, 6, 3)) // 10\n```\n\n> 用法 3：合并对象属性\n\n```js\n//合并对象属性\nvar obj = { name: 'zs', age: 12 }\nvar obj2 = { age: 14, addr: 'gz' }\nconsole.log({ ...obj, ...obj2 }) // {name:\"zs\",age:14,addr:\"gz\"}\n```\n\n> 用法 4：合并数组\n\n```js\n//合并数组\nvar arr = [1, 2]\nvar arr2 = [3, 4]\nconsole.log(...arr, ...arr2) // 1 2 3 4\n```\n\n> 用法 5：解构赋值\n\n```js\n//解构赋值\nvar [a, ...b] = [3, 4, 5] //注意：展开运算符之能放在左后一个元素上\nconsole.log(a) // 3\nconsole.log(b) // 数组[4,5]\n```\n\n> 用法 6：分解字符串\n\n```js\n//分解字符串\nvar str = 'test'\nconsole.log(...str) // t e s t\nvar [a, b, c, d] = [...str]\nconsole.log(a) // t\nconsole.log(b) // e\nconsole.log(c) // s\nconsole.log(d) // t\n```\n","tags":["前端","ES6","js"],"categories":["前端","js"]},{"title":"vue面试题总结","url":"/2020/07/20/Vue/vue常见面试题/","content":"\n## vue面试题汇总\n\n### 1. **vuex** 的作用\n\n- vuex是一个专门为vue.js应用程序开发提供的全局状态管理；\n\n- vuex是一个状态管理的插件，可以解决不同组件之间的数据共享和数据持久化；\n- vuex的几个核心概念：\n  - vuex使用store对象管理应用的状态，store包括：state，getter，mutation，action四个属性\n  \n  - state：状态，是vuex状态管理的数据源；\n  - getter：getter的作用相当于vue中的computed(计算属性)，可以将state的数据加工之后返回，当state中的数据发生变化的时候，返回的数据可以跟着变化；\n  - mutation：mutation是vuex中唯一可以修改state中状态的途径，需要通过commit进行调用，而且mutation可以接收参数，也就是载荷（payload）： **store.commit('add', 5)**\n  - action：一些对state的异步操作可以放在action中，并通过在action提交mutation变更状态；\n  - module：当我们vuex状态管理的数据相当多的时候，就需要用到module，将store分割成多个模块，每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块\n- 使用的时候：我们可以在组件中触发 Action，Action 则会提交 Mutation，Mutaion 会对 State 进行修改，组件再根据 State 、Getter 渲染页面。\n\n### 2. **vuex** 的路由拦截器的作用和使用\n\n- 作用：\n  - 可以用来判断token是否存在，不存在的话跳转到登陆界面；\n- 使用：\n![路由拦截](01.png)\n\n### 3. **axios** 的作用\n\n- axios也就是实现异步请求的工具，与js的ajax作用相同；\n- axios的特点：\n  - 从浏览器中创建XMLHttpRequests；\n  \n  - 从node.js创建http请求；\n  - 支持promise API；\n  - 可以拦截请求和响应；\n``` javascript\n//请求拦截器\naxios.interceptors.request.use(function(config){\n    return config;\n},function(error){\n    return Promise.reject(error);\n});\n//响应拦截器\naxios.interceptors.response.use(function(response){\n    return response;\n},function(error){\n    return Promise.reject(error);\n});\n```\n  - 可以转换请求和相应中的数据；\n  - 客户端支持防御XSRF/CSRF (是一种跨站的伪造的请求，指的是跨站伪造用户的请求，模拟用户的操作);\n- promise:\n\n  - 是一个对象，用来传递异步操作的信息；\n  \n  - 有效的解决了多次回调中请求的问题；\n\n### 4. 列举vue中常见的指令\n\n- Vue的渲染\n  - **插值表达式：**\n``` html\n<!-- 文本插值： {{ msg }} -->\n<div style=\"color: red\">\n    <div> {{ message }} </div>\n</div>\n```\n  \n  - v-html：它可以加标签，它会解析成html\n  - v-text：不能加标签，如果加了，它会当作字符串展示出来；\n  - v-text与插值表达式的区别：\n  >默认v-text没有闪烁的问题的，而插值表达式有闪烁问题 v-text 会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，不会把整个元素的内容清空\n  - v-html 与 v-text的区别：\n>v-html会解析html格式;v-text与插值表达式会把内容当做文本来解析;v-html和 v-text都会覆盖元素中原有的内容\n  - 指令绑定一个事件监听器：v-on\n``` html\n<!-- 绑定click事件 -->\n<div style=\"color: red\">\n    <div v-on:click=\"changeMessage\"> {{ message }} </div>\n</div>\n<!-- vue2.0写法 -->\n<div style=\"color: red\">\n    <div @click=\"changeMessage\"> {{ message }} </div>\n</div>\n```\n  - DOM属性绑定：**v-bind**\n``` html\n<!-- 绑定class属性 -->\n<div v-bind:class='active'>\n    <div> {{ message }} </div>\n</div>\n<!-- vue2.0写法 -->\n<div :class='active'>\n    <div> {{ message }} </div>\n</div>\n```\n  - 实现表单输入和应用状态之间的双向绑定：**v-model**\n``` html\n<div id='app-6'>\n    <p>{{message}}</p>\n    <input v-model='message'>\n</div>\n```\n  - 控制一个元素的显示： **v-if &nbsp; v-show** ( 两者的区别是v-if如果为false的话dom元素就不存在，v-show为false的话相当于将dom节点隐藏起来，其实是进行了加载的 )\n  - 列表渲染：**v-for**\n``` html\n<ol>\n  <li v-for='(todo,i) in todos' :key=\"i\">\n      {{todo.text}}\n  </li>\n</ol>\n```\n\n### 5. 对于 **MVVM** 的理解\n\n- **MVVM** 是 Model-View-ViewModel 的缩写；\n  \n- **Model** 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；\n- **View** 代表 UI 组件，它负责将数据模型转化成 UI 展现出来；\n- **ViewModel** 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View；\n- **ViewModel 和 Model**实现了数据的双向绑定;\n\n### 6.Vue实现数据双向绑定的原理\n\n采用**数据劫持**结合**发布者-订阅者模式**的方式，通过**Object.defineProperty()**来劫持各个属性的getter和setter，在数据变动后发布消息给订阅者，触发相应监听回调。\n\n- Vue的核心**<font color=\"red\">数据劫持</font>**\n数据劫持是借助到Object.defineProprety(obj,prop,descriptor)函数的；\n\n - 参数：\n  obj:目标对象\n  prop:需要定义的属性或方法的名称\n  descriptor:目标属性所拥有的特性\n\n  - 可供定义的特性列表:\n  \n    value：属性的值\n    writable：如果为false，属性的值就不能被重写。\n    get： 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。\n    set：一旦目标属性被赋值，就会调回此方法。\n    configurable: 如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。\n    enumerable： 是否能在for...in循环中遍历出来或在Object.keys中列举出来。\n\n- 什么是数据劫持？\n  \n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对Object.defineProprety(obj,prop,descriptor)的了解，我们不难发现，当我们访问或者设置对象属性的时候，都会触发相应的函数，然后在这个函数里返回一些东西；\n\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然我们了解到会触发的这些函数，那我们就可以在这个函数中进行一些我们需要的操作，而这个过程也就是**<font color=\"red\">劫持</font>**\n\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Vue中其实就是利用Object.defineProprety()来劫持对象属性的setter和getter操作，并设置一个监听器，当数据发生变化的时候发出通知；\n\n  例子：\n  ```js\n  var data = {\n    name:'lhl'\n  }\n\n  Object.keys(data).forEach(function(key){\n      Object.defineProperty(data,key,{\n          enumerable:true, \n          configurable:true, \n          get:function(){\n              console.log('get');\n          },\n          set:function(){\n              console.log('监听到数据发生了变化');\n          }\n      })\n  })\n  data.name //控制台会打印出 “get”\n  data.name = 'hxx' //控制台会打印出 \"监听到数据发生了变化\"\n  ```\n\n  这里我们可以看出，我们可以控制对象属性的设置和读取；\n\n### 7.$nextTick的使用\n\n#### 7.1 什么是$nextTick\n\n- **简单回答**：因为Vue的异步更新队列，$nextTick是用来知道什么时候DOM更新完成的;\n- **详细案例**：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看这样一个场景：有一个div，默认用v-if将它隐藏，点击一个按钮后，改变v-if的值，让它显示出来，同时拿到这个div的文本内容。如果v-if的值是 false，直接去获取div内容是获取不到的，因为此时div还没有被创建出来，那么应该在点击按钮后，改变v-if的值为 true，div才会被创建，此时再去获取，示例代码如下：\n\n  ```js\n  <template>\n    <div>\n      <ul>\n        <li id='msg' v-if=\"show\">Hello World!</li>\n      </ul>\n    </div>\n  </template>\n  export default {\n    data() {\n      return {\n        show: false\n      }\n    },  \n    mounted() {\n      this.showDetail()\n    },\n    methods: {\n      showDetail() {\n        this.show = true\n        console.log(document.getElementById('msg').innerHTML)\n      }\n    },\n  }\n  ```\n\n  这段代码运行后控制台会抛出错误信息：<font color=\"red\">Cannot read property 'innnerHTML of null，意思就是获取不到 li 元素</font>\n  这里就涉及到 **Vue** 一个重要的概念：<font color=\"#316fe0\">异步更新队列</font>\n\n#### 7.2 异步更新队列\n\n- Vue在观察到数据变化时 <font color=\"#316fe0\">并不是直接更新DOM，而是开启一个队列，</font> 并缓冲在同一个事件循环中发生的所有数据改变。在缓冲时会<font color=\"#316fe0\">去除重复数据，</font> 从而避免不必要的计算和DOM操作。然后，在下一个事件循环tick中，Vue刷新队列并执行实际（已去重的）工作。所以如果你用一个for循环来动态改变数据100次，其实它只会应用最后一次改变，如果没有这种机制，DOM就要重绘100次，这固然是一个很大的开销;\n\n- Vue会根据当前浏览器环境优先使用原生的Promise.then和MutationObserver，如果都不支持，就会采用setTimeout代替。\n\n- 因此上面的示例报错的原因是执行过``` this.show = true ```之后 **Dom** 节点还没有创建，在下一个Vue事件循环试才开始创建，<font color=\"#316fe0\">$nextTick</font>就是用来知道 **Dom** 是什么时候更新完成的，示例修改为以下情况就会输出正常：\n\n  ```js\n  <template>\n    <div>\n      <ul>\n        <li id='msg' v-if=\"show\">Hello World!</li>\n      </ul>\n    </div>\n  </template>\n  export default {\n    data() {\n      return {\n        show: false\n      }\n    },  \n    mounted() {\n      this.showDetail()\n    },\n    methods: {\n      showDetail() {\n        this.show = true\n        this.$nextTick(() => {\n          console.log(document.getElementById('msg').innerHTML)\n        })\n      }\n    },\n  }\n  ```\n\n> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**理论上我们在使用Vue开发过程中是不需要对Dom进行操作的，但是在一些业务里边，我们不可避免的会使用一些第三方插库，比如 popper.js、swiper等，这些基于原生javascript的库都有创建和更新及销毁的完整生命周期，与Vue配合使用时，就要利用好$nextTick**\n","tags":["前端","vue","面试"],"categories":["前端","vue"]},{"title":"Grid 网格布局","url":"/2020/07/14/CSS/css-grid/","content":"\n## 一、Grid 布局简介\n\n- 网格布局 **(Grid)** 是最强大的 **CSS** 布局方案；\n\n- 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了；\n  ![Grid拿手效果](shili.jpg)\n\n- **Flex** 相当于一维布局，**Grid** 相当于二维布局，因此 **Grid** 相比于 **Flex** 要强大得多。\n\n## 二、基本概念\n\n### （1） 容器和项目\n\n- 采用网格布局的区域，称为\"容器\"（**container**），容器内部采用网格定位的子元素，称为\"项目\"（**item**）。\n\n  ```html\n  <div id=\"container\">\n    <div class=\"item item-1\">1</div>\n    <div class=\"item item-2\">2</div>\n    <div class=\"item item-3\">3</div>\n    <div class=\"item item-4\">4</div>\n    <div class=\"item item-5\">5</div>\n    <div class=\"item item-6\">6</div>\n    <div class=\"item item-7\">7</div>\n    <div class=\"item item-8\">8</div>\n    <div class=\"item item-9\">9</div>\n  </div>\n  ```\n\n- <font color=\"#389a6e\">**注意：项目只能是容器的顶层子元素，不包含项目的孙子元素。**</font>\n\n### （2） 行和列\n\n- 容器里面的水平区域称为\"行\"（**row**），垂直区域称为\"列\"（**column**）；\n\n### （3） 单元格\n\n- 行和列的交叉区域，称为\"单元格\"（cell）。\n  正常情况下，n 行和 m 列会产生 **n \\* m** 个单元格。比如，3 行 3 列会产生 9 个单元格。\n\n### （4） 网格线\n\n- 划分网格的线，称为\"网格线\"（grid line）。水平网格线划分出行，垂直网格线划分出列。\n  正常情况下，n 行有 **n + 1** 根水平网格线，m 列有 **m + 1** 根垂直网格线，比如三行就有四根水平网格线。\n  ![4 x 4 的网格，共有5根水平网格线和5根垂直网格线。](gridLine.jpg)\n\n## 三、容器 (container) 属性\n\n首先展示一下[未设置网格属性](https://jsbin.com/rorubug/edit?html,css,output)时的样式和效果\n\n![未设置时的效果图](01.jpg)\n\n### （1） display 属性\n\n- `display: grid` 设置一个元素为网格布局；\n\n- `display: inline-grid` 设置元素为行内网格布局；\n\n> 注意：**设置网格布局之后**，容器的子元素（项目）的 `float、display: inline-block、display: table-cell、vertical-align 和 column-*` 属性都将失效；\n\n### （2）grid-template-columns 属性和 grid-template-rows 属性\n\n- 容器指定了网格布局以后，接着就要划分行和列。**grid-template-columns**属性定义每一列的列宽，**grid-template-rows**属性定义每一行的行高。\n\n  ```css\n  // 指定了一个三行三列的网格，列宽和行高都是100px。\n  #container {\n    display: grid;\n    grid-template-columns: 100px 100px 100px;\n    grid-template-rows: 100px 100px 100px;\n  }\n  // 还可以使用百分比\n  #container {\n    display: grid;\n    grid-template-columns: 33.3% 33.3% 33.3%;\n    grid-template-rows: 100px 100px 100px;\n  }\n  ```\n\n![设置一个三行三列的网格](02.png)\n\n#### （2.1） **repeat()** 函数\n\n- **repeat()** 接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值。\n\n  ```css\n  #container {\n    display: grid;\n    grid-template-columns: repeat(3, 20%);\n    grid-template-rows: repeat(3, 100px);\n  }\n  ```\n\n![效果如图](03.png)\n\n- **repeat()** 也可以用来重复某种格式；\n\n  `grid-template-columns: repeat(2, 100px 20px 80px);` 设置网格 6 列 第一列和第四列的宽度为 100px，第二列和第五列为 20px，第三列和第六列为 80px\n  ![网格6列，三列重复两次](04.png)\n\n- **auto-fill** 关键字配合 **repeat()** 的使用；\n\n  `grid-template-columns: repeat(auto-fill, 100px);` 表示每列宽度 100px，然后自动填充，直到容器不能放置更多的列；\n  ![100px自动填充](auto-fill.png)\n\n#### （2.2）**fr** 关键字\n\n- **fr** 关键字是为了表示行或者列的比例关系\n  `grid-template-columns: 1fr 1fr;` 表示设置两个宽度的列；\n\n- **fr** 可以和绝对长度的单位结合使用；\n  `grid-template-columns: 150px 1fr 2fr;` 表示第一列的宽度为 150 像素，第二列的宽度是第三列的一半；\n  ![fr和px结合使用](fr.png)\n\n#### （2.3）**minmax()** 函数\n\n- **minmax()** 函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值；\n  `grid-template-columns: 1fr 1fr minmax(100px, 1fr);` 表示列宽**不小于 100px，不大于 1fr**\n\n#### （2.4）**auto** 关键字\n\n- **auto** 关键字表示由浏览器自己决定长度；\n  `grid-template-columns: 100px auto 100px;` 第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了 min-width，且这个值大于最大宽度;\n\n#### （2.5）网格线的名称\n\n- grid-template-columns 属性和 grid-template-rows 属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。\n\n  ```css\n  .container {\n    display: grid;\n    grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4 last];\n    grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4 last];\n  }\n  ```\n\n  上面代码指定网格布局为 3 行 x 3 列，因此有 4 根垂直网格线和 4 根水平网格线。方括号里面依次是这八根线的名字; **线的名称可以定义两个，也可以是多个**；\n\n#### （2.6）布局实例\n\n- `grid-template-columns: 70% 30%;` 实现了**两栏布局**；\n\n- `grid-template-columns: repeat(12, 1fr);` 实现了传统栅格模式的 **12 栏布局**；\n\n### （3）row-gap、column-gap 和 grid-gap 属性\n\n- **row-gap** 属性设置行与行的间隔（行间距）；\n  `row-gap: 20px;` 行间距设为 20px\n\n- **column-gap** 属性设置列与列的间隔（列间距）；\n  `column-gap: 20px;` 列间距设为 20px\n\n- **grid-gap** 是 column-gap 和 row-gap 的合并简写形式\n  `grid-gap: 20px 20px;` 行间距和列间距都是 20px；等同于 `grid-gap: 20px;`\n\n### （4）grid-template-areas 属性\n\n- 网格布局允许指定\"区域\"（area），一个区域由单个或多个单元格组成;\n- **grid-template-areas** 属性用于定义区域。\n\n  ```css\n  .container {\n    display: grid;\n    grid-template-columns: 100px 100px 100px;\n    grid-template-rows: 100px 100px 100px;\n    grid-template-areas:\n      'a b c'\n      'd e f'\n      'g h i';\n  }\n  ```\n\n  先划分出 9 个单元格，然后将其定名为 a 到 i 的九个区域，分别对应这九个单元格。\n\n- 多个单元格合并成一个区域的写法如下。\n\n  ```css\n  将 9 个单元格分成 a、b、c 三个区域。\n  grid-template-areas:\n    'a a a'\n    'b b b'\n    'c c c';\n  ```\n\n  如果某些区域不需要利用，则使用\"点\"（.）表示。\n\n  ```css\n  // 中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域\n  grid-template-areas:\n    'a . c'\n    'd . f'\n    'g . i';\n  ```\n\n> 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为 **区域名-start**，终止网格线自动命名为 **区域名-end**。\n\n### （5）grid-auto-flow 属性\n\n- 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。**默认的放置顺序是\"先行后列\"，即先填满第一行，再开始放入第二行，** 这个顺序由 **grid-auto-flow** 属性决定，默认值是 **row**，即\"**先行后列**\"。也可以将它设成 **column**，变成\"**先列后行**\"。\n\n- **grid-auto-flow** 属性除了设置成 row 和 column，还可以设成 **row dense** 和 **column dense**。这两个值主要用于，某些项目指定位置以后，**剩下的项目怎么自动放置**。\n\n### （6）justify-items，align-items，place-items\n\n- justify-items 属性设置单元格内容的水平位置（左中右），align-items 属性设置单元格内容的垂直位置（上中下）;\n\n  - **start：对齐单元格的起始边缘**\n  - **end：对齐单元格的结束边缘**\n  - **center：单元格内部居中**\n  - **stretch：拉伸，占满单元格的整个宽度（默认值）**\n\n  ```css\n  .container {\n    justify-items: start | end | center | stretch;\n    align-items: start | end | center | stretch;\n  }\n  ```\n\n- `.container { justify-items: start; }` 表示单元格的内容左对齐\n  ![内容左对齐](justify-items.png)\n\n- `.container { align-items: start; }` 表示单元格的内容头部对齐\n  ![内容头部对齐](align-items.png)\n\n- **place-items** 属性是 **align-items** 属性和 **justify-items** 属性的合并简写形式: `place-items: <align-items> <justify-items>;`\n\n### （7）justify-content、align-content、place-content\n\n- **justify-content** 属性是整个内容区域在容器里面的水平位置（左中右），\n\n- **align-content** 属性是整个内容区域的垂直位置（上中下）\n\n  - **start - 对齐容器的起始边框**\n\n  - **end - 对齐容器的结束边框**\n\n  - **center - 容器内部居中**\n\n  - **stretch - 项目大小没有指定时，拉伸占据整个网格容器**\n\n  - **space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍**\n\n  - **space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔**\n\n  - **space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔；**\n\n- **place-content** 属性是 **align-content** 属性和 **justify-content** 属性的合并简写形式：`place-content: <align-content> <justify-content>`\n\n### （8）grid-auto-columns、grid-auto-rows\n\n- 有时候，一些子元素（项目）的指定位置，在现有网格的外部。比如网格只有 3 行，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目\n\n- **grid-auto-columns** 属性和 **grid-auto-rows** 属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与 **grid-template-columns** 和 **grid-template-rows** 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。\n\n- 下面的例子里面，划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: 100px 100px 100px;\n  grid-template-rows: 100px 100px 100px;\n  grid-auto-rows: 50px;\n}\n```\n\n![行高填充为50px](05.png)\n\n## 四、项目属性\n\n### （1）指定项目的位置\n\n- **grid-column-start**：左边框所在的垂直网格线\n\n- **grid-column-end**：右边框所在的垂直网格线\n\n- **grid-row-start**：上边框所在的水平网格线\n\n- **grid-row-end**：下边框所在的水平网格线\n\n  下面的例子是**指定四个边框位置**的效果：\n\n  ```css\n  .item-1 {\n    grid-column-start: 1;\n    grid-column-end: 3;\n    grid-row-start: 2;\n    grid-row-end: 4;\n  }\n  ```\n\n  ![指定四个边框位置](06.png)\n\n  **这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字**:\n\n  ```css\n  .item-1 {\n    grid-column-start: header-start;\n    grid-column-end: header-end;\n  }\n  ```\n\n  这四个属性的值还可以使用 **span** 关键字，表示\"跨越\"，即**左右边框（上下边框）之间跨越多少个网格**: `.item-1 { grid-column-start: span 2; }`\n  ![1号项目的左边框距离右边框跨越2个网格](07.png)\n\n> **使用这四个属性，如果产生了项目的重叠，则使用 z-index 属性指定项目的重叠顺序。**\n\n### （2）grid-column、grid-row\n\n- **grid-column** 属性是 **grid-column-start** 和 **grid-column-end** 的合并简写形式：`grid-column: <start-line> / <end-line>;`\n\n- **grid-row** 属性是 **grid-row-start** 属性和 **grid-row-end** 的合并简写形式：`grid-row: <start-line> / <end-line>;`\n\n  ```css\n  .item-1 {\n    grid-column: 1 / 3;\n    grid-row: 1 / 2;\n  }\n  /* 等同于 */\n  .item-1 {\n    grid-column-start: 1;\n    grid-column-end: 3;\n    grid-row-start: 1;\n    grid-row-end: 2;\n  }\n  /* ====================== */\n  .item-1 {\n    background: #b03532;\n    grid-column: 1 / 3;\n    grid-row: 1 / 3;\n  }\n  /* 等同于 */\n  .item-1 {\n    background: #b03532;\n    grid-column: 1 / span 2;\n    grid-row: 1 / span 2;\n  }\n  ```\n\n### （3）grid-area 属性\n\n- grid-area 属性指定项目放在哪一个区域。\n\n  1 号项目位于 e 区域：`.item { grid-area: e; }`\n\n  ![grid-area](08.png)\n\n- **grid-area** 属性还可用作 **grid-row-start**、**grid-column-start**、**grid-row-end**、**grid-column-end** 的合并简写形式，直接指定项目的位置：`grid-area: <row-start> / <column-start> / <row-end> / <column-end>;`\n\n### （4）justify-self、align-self、place-self\n\n- **justify-self** 属性设置单元格内容的水平位置（左中右），跟 **justify-items** 属性的用法完全一致，但只作用于单个项目；\n\n- **align-self** 属性设置单元格内容的垂直位置（上中下），跟 **align-items** 属性的用法完全一致，也是只作用于单个项目。\n\n- **place-self** 属性是 **align-self** 属性和 **justify-self** 属性的合并简写形式：`place-self: <align-self> <justify-self>;`\n","tags":["前端","css","flex","布局"],"categories":["前端","css","布局"]},{"title":"CSS样式优先级","url":"/2020/07/13/CSS/cssPriority/","content":"\n>当创建的样式文件越来越复杂时，一个标签的样式将会受到越来越多的影响，这种影响可能来自周围的标签，也可能来自其自身。下面我们从这两方面去看看 CSS 样式的优先级。\n\n### CSS的**继承性**\n\nCSS 的继承特性指的是应用在一个标签上的那些 CSS 属性被传到其子标签上。看下面的 HTML 结构：\n\n``` html\n<div>\n    <p></p>\n</div>\n```\n\n如果 **&#60;div&#62;** 有个属性 **color: red**，则这个属性将被 **&#60;p&#62;** 继承，即 **&#60;p&#62;** 也拥有属性 **color: red**。<br>\n由上可见，当网页比较复杂， HTML 结构嵌套较深时，一个标签的样式将深受其祖先标签样式的影响。影响的规则是：\n\n#### CSS 优先规则\n\n1. 最近的祖先样式比其他祖先样式优先级高。\n\n例1：\n``` html\n<!-- 类名为 son 的 div 的 color 为 blue -->\n<div style=\"color: red\">\n    <div style=\"color: blue\">\n        <div class=\"son\"></div>\n    </div>\n</div>\n```\n如果我们把一个标签从祖先那里继承来的而自身没有的属性叫做 **祖先样式** ，那么 **直接样式** 就是一个标签直接拥有的属性。又有如下规则：\n\n2. **直接样式** 比 **祖先样式** 优先级高。\n\n例2：\n``` html\n<!-- 类名为 son 的 div 的 color 为 blue -->\n<div style=\"color: red\">\n    <div class=\"son\" style=\"color: blue\"></div>\n</div>\n```\n\n#### CSS 选择器的优先级\n\n上面讨论了一个标签从祖先继承来的属性，现在讨论标签自有的属性。在讨论 CSS 优先级之前，先说说 CSS 7 种基础的选择器：\n- ID 选择器， 如 #id{}\n- 类选择器， 如 .class{}\n- 属性选择器， 如 a[href=\"segmentfault.com\"]{}\n- 伪类选择器， 如 :hover{}\n- 伪元素选择器， 如 ::before{}\n- 标签选择器， 如 span{}\n- 通配选择器， 如 *{}\n\n>优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器\n\n例3：\n``` html\n// HTML\n<div class=\"content-class\" id=\"content-id\" style=\"color: black\"></div>\n```\n``` css\n// CSS\n#content-id {\n    color: red;\n}\n.content-class {\n    color: blue;\n}\ndiv {\n    color: grey;\n}\n```\n最终的 color 为 black，因为内联样式比其他选择器的优先级高。\n\n所有 CSS 的选择符由上述 7 种基础的选择器或者组合而成，组合的方式有 3 种：\n- 后代选择符： .father .child{}\n- 子选择符： .father > .child{}\n- 相邻选择符: .bro1 + .bro2{}\n\n当一个标签同时被多个选择符选中，我们便需要确定这些选择符的优先级。我们有如下规则：\n\n>计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照\"就近原则\"来判断。\n\n例4：\n``` html\n// HTML\n<div id=\"con-id\">\n    <span class=\"con-span\"></span>\n</div>\n```\n``` css\n// CSS\n#con-id span {\n    color: red;\n}\ndiv .con-span {\n    color: blue;\n}\n```\n此例中：（a）的个数为 1；（b）的个数为 1；（c）的个数为 2；两个标签选择器根据 **就近原则** 的话最终生效的是 **color：red** 的属性 <br>\n如果外部样式表和内部样式表中的样式发生冲突会出现什么情况呢？这与样式表在 HTML 文件中所处的位置有关。样式被应用的位置越在下面则优先级越高，其实这仍然可以用 **例 4** 来解释。\n\n例5：\n``` css\n// HTML\n<link rel=\"stylesheet\" type=\"text/css\" href=\"style-link.css\">\n<style type=\"text/css\">\n@import url(style-import.css); \ndiv {\n    background: blue;\n}\n</style>\n\n<div></div>\n\n// style-link.css\ndiv {\n    background: lime;\n}\n\n// style-import.css\ndiv {\n    background: grey;\n}\n```\n从顺序上看，内部样式在最下面，被最晚引用，所以**&#60;div&#62;**的背景色为 blue。\n\n上面代码中，@import 语句必须出现在内部样式之前，否则文件引入无效。\n\nCSS 还提供了一种可以完全忽略以上规则的方法，当你一定、必须确保某一个特定的属性要显示时，可以使用这个技术。\n\n>属性后插有 !important 的属性拥有最高优先级。若同时插有 !important，则再利用规则 3、4 判断优先级。","tags":["前端","css"],"categories":["前端","css"]},{"title":"cookie的优缺点","url":"/2020/07/08/cookie/","content":"\n## cookie的优缺点\n\n### cookie的弊端\n\n>cookie虽然在持久板寸客户端数据提供了方便，分担了服务器储存的负担，但是还是有许多局限性的\n- 不同的浏览器和不同版本会限制每个域名的cookie个数\n- IE6或更低版本最多20个cookie \n- IE7和之后的版本最多50个cookie\n- Firefox最多50个cookie\n- Chrome和Safari没有硬性限制\n- IE和Opera会清理掉近期最少使用的cookie而Firefox会随机清理掉一些cookie\n- Cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节\n\n### cookie的优点：极高的扩展性和可用性\n\n- 通过良好的编程习惯，控制保存在cookie中的session对象的大小\n- 通过加密和安全传输技术（SSL），减少cookie被破解的可能性\n- 只在cookie中存放不敏感数据，即使被盗也不会有重大损失\n- 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie\n\n[参考博客](https://www.cnblogs.com/keyng/p/12883343.html)","tags":["前端","面试","cookie"],"categories":["前端"]},{"title":"hexo博客在云服务器上的部署","url":"/2020/07/07/hexoDeploy/","content":"\n# 今天来记录一下部署hexo的步骤\n\n## 部署所需的系统配置\n\n- 本地windows 10系统；\n- 云服务器是阿里云 CentOS7 系统；\n- 如果想要使用域名的话可以准备一个域名；\n  \n## 本地主机所需配置\n\n- 安装 Git；\n- 安装 NodeJs；\n- 安装 Hexo；\n- 根据 [Hexo官网](https://hexo.bootcss.com/) 创建自己的博客，可以选择一个自己喜欢的主题；\n\n## 云主机所需配置\n\n- 安装git，为了在云服务器上创建仓库；\n- 安装nginx，利用反向代理将请求代理到博客资源所在的位置；\n\n## 接下来开始进行配置\n\n### 1、 生成 ***ssh*** 公钥\n\n&nbsp;&nbsp;在本地windows进入win+R进入cmd(命令行终端)执行以下命令：\n\n```\n  ssh-keygen -t rsa\n```\n\n&nbsp;&nbsp;如果有选择就同意，没有的话就一直点击回车；执行成功之后会在<br>\n>我的电脑/C盘/用户/你自己的用户名/.shh/ \n\n&nbsp;&nbsp;所在的位置生成 *id_rsa，id_rsa.pub* 文件，如果出现这些文件，证明成功。\n\n>注：如果后边遇到问题需要重新生成公钥的话，**建议删除该文件夹下的所有文件重新生成**！\n\n### 2、 远程CentOS系统配置步骤\n\n#### 安装git，使用下面命令：\n\n```\n  yum install git\n```\n\n#### 创建Git账户：\n\n```\n  addUser git\n```\n\n设置git账户密码\n\n```\n  sudo passwd git\n```\n按照提示输入两次密码\n\n#### 给账户添加权限：\n\n```\n  chmod 740 /etc/sudoers\n  vim /etc/sudoers\n```\n\n找到以下配置：\n\n```\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)     ALL\n```\n\n在后面添加：\n\n```\ngit    ALL=(ALL)     ALL\n```\n\n保存退出并且改回权限\n\n```\nchmod 400 /etc/sudoers\n```\n\n#### 配置云服务器上的 ***ssh*** \n\n首先切换到git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，设置相应的权限\n\n```\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n# 然后将win10中生成的.ssh文件夹下的 id_rsa.pub 文件中的公钥复制到authorized_keys\nchmod 600 /home/git/.ssh/authorized_keys\nchmod 700 /home/git/.ssh\n```\n\n完成之后需要在本地windows主机上测试是否可以免密登录git,在windows的命令行中使用：\n\n```\n#SERVER 代表云主机的ip地址\nssh -v git@SERVER\n```\n\n如果选择yes之后直接登陆成功的话说明配置成功。\n\n#### 在云服务器上配置 git 仓库\n\n首先创建文件夹作为git仓库的目录并修改权限(使用root用户)\n\n```\nmkdir /var/repository\nchown -R git:git /var/repository\nchmod -R 755 /var/repository\n```\n\n然后创建网站的根目录(也就是博客文件的目录),x修改权限\n\n```\nmkdir /home/hexo\nchown -R git:git /home/hexo\nchmod -R 755 /home/hexo\n```\n\n然后创建一个 Git 裸仓库\n\n```\ncd /var/repository\ngit init --bare hexoBlog.git\n```\n\n创建一个新的 Git 钩子，用于自动部署<br>\n我们找到 /var/repository/hexoBlog.git 下自动生成的hooks文件夹，在里边新建post-receive文件\n\n```\nvim /var/repository/hexoBlog.git/hooks/post-receive\n```\n\n并且在里边配置如下命令：\n\n```\n#!/bin/bash\ngit --work-tree=/home/hexo --git-dir=/var/repository/hexoBlog.git checkout -f\n```\n\n将工作树( ***项目地址*** )和git仓库( ***hexoBlog.git*** )关联起来,这样从本机提交上的项目就可以同步到 ***/home/hexo*** 路径下，保存后修改文件权限，添加可执行权限：\n\n```\nchown -R git:git /var/repository/hexoBlog.git/hooks/post-receive\nchmod +x /var/repository/hexoBlog.git/hooks/post-receive\n```\n\n#### 在云服务器上配置 Nginx\n\n安装nginx ( 大家到百度自行查询安装方法 )\n\n修改nginx配置文件 nginx.conf 中的配置\n\n\n```\nserver {\n        listen       80;    #nginx反向代理的端口号\n\t\tserver_name  【填写域名或者云主机IP地址】; \n\t\troot       /home/hexo;       #网站的根目录\n\t\tlocation / {\n\t\t\n\t\t}\n        error_page 404 /404.html;         #配置40x页面\n        location = /40x.html {\n\t\t}\n    }\n```\n修改完成之后重启nginx服务\n\n#### 配置本地hexo项目的配置文件 _config.yml\n\n找到 deploy: 进行如下配置\n\n```\ndeploy:\n  type: git\n  repo: root@Server:/var/repository/hexoBlog.git    \n  branch: master      # 分支\n```\n> ** 注意：这里的格式一定要严格的按照缩进来进行 **\n\n然后找到hexo项目目录 ， 在文件路径输入 cmd 进入命令行 执行下面命令：\n\n```\nhexo c\nhexo g -d\n```\n\n如果执行结束之后显示成功，就可以在浏览器输入IP地址进行访问了","tags":["博客"]}]